/// 不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST
/// 
/// 
/// 编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知。对于动态类型，我们使用 DST(dynamically sized types)或者 unsized 类型
/// 
/// Rust 中常见的 DST 类型有: str、[T]、dyn Trait，它们都无法单独被使用，必须要通过  【引用】  或者  【Box 间接使用 】
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 【str】
/// 
/// 
/// 
/// 既不是 String 动态字符串，也不是 &str 字符串切片，而是一个 str
/// 
/// 它是一个动态类型，同时还是 String 和 &str 的底层数据类型。 
/// 
/// 
/// 由于 str 是动态类型，因此它的大小直到运行期才知道
/// 
/// 
/// 
/// [错误示例]
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///             #![allow(unused)]
///             fn main() {
/// 
///                 let s1: str = "Hello there!";           // 编译失败
///                 let s2: str = "How's it going?";        // 编译失败
///                 
///                 let s3: &str = "on?";                   // OK
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 【Sized Trait】  表示 固定大小
/// 
/// 
///             【所有在编译时就能知道其大小的类型，都会自动实现 Sized 特征】
/// 
/// 
///             #![allow(unused)]
///             fn generic<T: Sized>(t: T) {    // T 在这里被限定为 【固定大小】
///                 // --snip--
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 【?Sized Trait】   表示 可能固定大小 或者 动态大小
/// 
/// 
/// 
/// 
/// 
///             #![allow(unused)]
///             fn generic<T: ?Sized>(t: &T) {
///                 // --snip--
///             }
///
/// 
/// 
/// 
/// 
///
/// 
/// ######################################################################################################################################################
/// 宏  的 定义 及 使用
/// ###################################################################################################################################################### 
/// 
/// 1、 声明宏：   编写类似于 match 表达式
/// 2、 过程宏：   对它所给的 Rust 代码的抽象语法树（AST）进行操作， 如: #[derive(Debug)]
/// 
/// 
/// 
/// 宏展开：  rustc -Zunpretty=expanded ./src/main.rs
/// 
/// 
/// ######################################################################################################################################################
/// 声明宏 的 定义 及 使用
/// ###################################################################################################################################################### 
/// 
/// 
/// 
/// 
/// 
/// 宏定义的内容由 规则(rule) 组成, 每一条规则都形如:
///
///  (Pattern) => { Exapnsion };
/// 
/// 其中所使用的的 括号  (), [], {} 是不受限制的, 调用时不会对括号进行检查.
/// 
/// () => {} 看起来很神秘, 因为它不是标准的 rust 语法, 是 macro_rules! 这个宏自己发明的, 用来表示一条宏规则:   "=>" 左边是【匹配模式】, 右边是【等待展开的代码】
/// 
/// 类似于Rust中的match语句, 在macro_rules!中可以定义多条宏规则,  当宏被调用时, 会由上而下对每个规则进行匹配, 如果某一条规则与输入 完全 匹配, 则立刻进行该规则所对应的展开.
/// 
///
/// 
/// macro_rules! hey{
///     () => {}, 
///     () => {}
/// }
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 又如:
/// 
/// 
/// macro_rules! add{
///     // first arm match add!(1, 2),  add!(2, 3) etc
///        ($a:expr, $b:expr)=>{
///            {
///                $a+$b
///            }
///        };
///    // Second arm macth add!(1),  add!(2) etc
///        ($a:expr)=>{
///            {
///                $a
///            }
///        }
///    }
///    
///    fn main(){
/// 
///        let x=0;
/// 
///        add!(1, 2);   // 匹配到 宏中 第一个规则
///        add!(x);     // 匹配到 宏中 第二个规则
///    }
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 宏的参数描述为:  
/// 
///         **************************
///         *   $参数名称: 参数类型   *
///         **************************
/// 
/// 如:         $a:expr
/// 
/// 参数类型叫做: 选择器、token类型
/// 
/// 
/// 
/// 
/// 【参数类型】
/// 
/// 
/// 
///         1、 item:           Item, 如：函数定义, 常量声明, 结构体, 模块, impl 块 等等
///         2、 block:          BlockExpression, 一个语句块 或 一个表达式, 由花括号所包围, 如: { ... }
///         3、 stmt:           Statement, 语句, 如: let 表达式 (传入为 stmt 类型的参数时 【不需要末尾的分号】, 但需要分号的 item 语句除外)
///         4、 pat:            Pattern, 模式匹配中的 【模式】, 如: Some(a)
///         5、 expr:           Expression, 表达式, 如: Vec::new()
///         6、 ty:             Type, 类型, 如: i32
///         7、 ident:          IDENTIFIER_OR_KEYWORD, 【标识符】 或 【关键字】, 如: i 或 self
///         8、 path:           TypePath, 类型路径, 如: std::result::Result
///         9、 tt:             TokenTree, Token 树 (单棵标记树), 被匹配的定界符 (、[] 或 {} 中的单个或多个 token
///         10、 meta:          Attr, 形如: #[...] 和 #![...] 的属性内部的内容
///         11、 lifetime:      LIFETIME_TOKEN, 生命周期 Token, 如: 'foo、'static
///         12、 vis:           Visibility, 可能为空的 【可见性限定符】, 如: pub、pub(in crate)
///         13、 literal:       LiteralExpression, 一个字面值, 如: "Hello World!"、3.14、'🦀'
/// 
///     【其中, tt 类型可以被视为 Rust 宏的 Any】
///      
///     【有一个特殊的元变量叫做 $crate ，它用来指代当前 crate】
/// 
/// 
/// 宏还对 各种类型的参数  捕获之后  所允许的内容  添加了限制, 以避免语义冲突:
/// 
/// 
/// 
///         1、 item: 任何标记
///         2、 block: 任何标记
///         3、 stmt: =>、;、,
///         4、 pat: =>、,、=、|、if 或 in
///         5、 expr: =>、;、,
///         6、 ty: {、[、=>、,、>、=、:、;、|、as 或 where
///         7、 ident: 任何标记
///         8、 path: {、[、=>、,、>、=、:、;、|、as 或 where
///         9、 meta: 任何标记
///         10、 tt: 任何标记
/// 
/// 
/// 
/// 【重复模式】
/// 
/// 
///         *****************************************************************************
///         *       $( 需要重复的内容 )      [可选的]分隔符          [必选的]重复标志   *
///         *                                                                           *
///         *  即： $( ... )                  sep                        rep            *
///         *****************************************************************************
/// 
/// sep    可选的分隔符:        常见的有 , 和 ;
/// 
/// rep    必选的重复标记:      三种     * (0 到 n 次)       + ( 1 到 n次)        ? (最多一次  ，所以此时不能前跟分隔标记)
/// 
/// 如:
///         $( $i:expr ),
///         $( $i:expr, )*
///         $( $i:expr ),* $(,)?
/// 
/// 
/// 如下:
/// 
/// 
///          入零个或多个相同类型的值, 构造一个包含这些值（按照顺序）的 Vec.
///        
///          macro_rules! build_vec {
///              (
///                  $( $i:expr ),*                          // 重复, 以支持任意数量的参数
///                  $(,)?                                   // 可选的末尾逗号
///              ) => {
///                  {                                       // 创建一个块, 以支持多条语句
///                      let mut vec = Vec::new();           // 构造一个 Vec, 必须为 mut, 否则下文无法进行 push
///          
///                      $(                                  // 重复, 将每个 $i 推入 vec 中
///                          vec.push($i);
///                      )*
///          
///                      vec                                 // 返回 vec
///                  }
///              }
///          }
///        
/// ----------------------------------------------------------------------------------------------
/// 
/// 又如:
/// 
/// 
///          macro_rules! add{
///  
///              // 单参数情况下
///                 ($a:expr)=>{
///                     $a
///                 };
///  
///             // 在传递两个参数的情况下
///                 ($a:expr,$b:expr)=>{
///                     {
///                         $a+$b
///                     }
///                 };
///  
///             // 使用其他参数再次调用 add 宏
///                 ($a:expr,$($b:tt)*)=>{
///                    {
///                        $a+add!($($b)*)
///                    }
///                 }
///             }
///             
///             fn main(){
///               println!("{}",add!(1,2,3,4));
///             }
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 又如:
/// 
/// 
/// 
/// 
///             macro_rules! make_public{
///                 (
///                  $(#[$meta:meta])*
///                  $vis:vis struct $struct_name:ident {
///                     $(
///                     $(#[$field_meta:meta])*
///                     $field_vis:vis $field_name:ident : $field_type:ty
///                     ),*$(,)+
///                 }
///                 ) => {
///             
///                         $(#[$meta])*
///                         pub struct $struct_name{
///                             $(
///                             $(#[$field_meta:meta])*
///                             pub $field_name : $field_type,
///                             )*
///                         }
///                 }
///             }
///             
///             fn main(){
///                 make_public!{
///                     #[derive(Debug)]
///                     struct Name{
///                         n:i64,
///                         t:i64,
///                         g:i64,
///                     }
///                 }
///             
///                 // 得到：
///                 // #[derive(Debug)]
///                 // pub struct name {
///                 //     pub n: i64,
///                 //     pub t: i64,
///                 //     pub g: i64,
///                 // }
///             }
///             
///             
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 
/// 
/// 【元变量表达式】
/// 
/// 
/// Rust 有一些特殊的元变量表达式（以下简称表达式）：transcriber (转码器) 可以使用这些表达式来获取有关元变量的信息
/// 
/// 
///             1. $$：                         展开为单个 $，这会有效地转义 $ 标记，因此它不会被展开 (转码)
///             2. ${count(ident)}：            【最里】层 $ident 总共重复的次数，相当于 ${count(ident, 0)}
///             3. ${count(ident，depth)}：     第 depth 层 $ident 总共重复的次数
///             4. ${index()}：                 【最里】层重复的当前重复的索引，相当于 ${index(0)}
///             5. ${index(depth)}：            在第 depth 层处当前重复的索引，向外计数
///             6. ${length()}：                【最里】层重复的【重复次数】，相当于 ${length(0)}
///             7. ${length(depth)}：           在第 depth 层重复的次数，向外计数
///             8. ${ignore(ident)}：           绑定 $ident 进行重复，并展开成空
///         
/// 
/// 
///     1. 【$$】
/// 
///     错误示例: (不用 $$ 时)
/// 
///             macro_rules! foo {
///                 () => {
///                     macro_rules! bar {
///                         ( $( $any:tt )* ) => { $( $any )* };    
///                         // ^^^^^^^^^^^ error: attempted to repeat an expression containing no syntax variables matched as repeating at this depth
///                         //
///                         // foo! 的 transcriber 看到有重复捕获的意图，并试图重复捕获，但它的作用域中没有 $any 元变量，这导致它产生错误.
///                         // 即在 foo 中没有 $any 元变量，则在 bar 中使用，则错误
///                     }
///                 };
///             }
///             
///             fn main() {
///                 foo!();
///             }
/// 
/// 
/// 
///     正确示例:  (使用 $$ 时)
/// 
///             #![feature(macro_metavar_expr)]
///             
///             macro_rules! foo {
///                 () => {
///                     macro_rules! bar {
///                         ( $$( $$any:tt )* ) => { $$( $$any )* };
///                     }
///                 };
///             }
///             
///             fn main() {
///                 foo!();
///                 bar!();
///             }
/// 
/// 
/// 
///         
///     2. 【${count(ident)}】 和 【${count(ident，depth)}】
/// 
///         
/// 
///         count 表达式展开成元变量 $ident 在给定重复深度的重复次数。
/// 
///         
///         
///                 ident 参数必须是规则作用域中声明的元变量
///                 depth 参数必须是值 <= 元变量 $ident 出现的最大重复深度的整型字面值
///                 count(ident, depth) 展开成不带后缀的整型字面值标记
///                 count(ident) 是 count(ident, 0) 的简写; 即： ${count(ident)} 相当于 ${count(ident，0)}
/// 
/// 
///         例如:  
///         
///                 ${count(x)} $( $x )*  
///         
///         表达式 ${count(x)} 将扩展为无后缀的整数文字，等于 $( $x )* 重复的重复次数。例如，如果元变量 $x 重复四次，那么它将扩展到整数文字 4
/// 
///         如果重复是嵌套的，则可以使用可选的深度参数来限制计算的嵌套重复的数量。例如，宏扩展如下：
/// 
///                 ${count(x, 1)} ${count(x, 2)} ${count(x, 3)} $( a $( b $( $x )* )* )*
/// 
///         扩展为的三个值是最外层重复次数（ a 生成的次数）、中间重复次数的总和（ b 生成的次数）以及 $x 的重复总数
/// 
///     
/// 
///             #![feature(macro_metavar_expr)]
///             
///             macro_rules! foo {
///                 ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {
///                     println!("count(outer, 0): $outer repeats {} times", ${count($outer)});                                             // 4
///                     println!("count(inner, 0): The $inner repetition repeats {} times in the outer repetition", ${count($inner, 0)});   // 3
///                     println!("count(inner, 1): $inner repeats {} times in the inner repetitions", ${count($inner, 1)});                 // 4
///                 };
///             }
///             
///             fn main() {
///                 foo! {
///                     outer () ;
///                     outer ( inner , inner ) ;
///                     outer () ;
///                     outer ( inner ) ;
///                 };
///             }
/// 
/// 
/// 
///     3. 【${index()}】和【${index(depth)}】
/// 
///         index(depth) 表达式展开为给定重复深度下，当前的迭代索引。
///             
///             depth 参数表明在第几层重复，这个数字  从最内层重复 调用表达式开始 向外 计算
///             index(depth) 展开成不带后缀的整型字面值标记
///             index() 是 index(0) 的简写
/// 
/// 
/// 
/// 
/// 
/// 
///             #![feature(macro_metavar_expr)]
///             // (("hello", 0, 0), ("indices", 1, 0), ("of", 1, 1), ("these", 3, 0), ("repetitions", 3, 1))
///             macro_rules! attach_iteration_counts {
///                 ( $( ( $( $inner:ident ),* ) ; )* ) => {
///                     ( $(
///                         $((
///                             stringify!($inner),
///                             ${index(1)},        // 这指的是外层重复
///                             ${index()}          // 这指的是内层重复，等价于 `index(0)`
///                         ),)*
///                     )* )
///                 };
///             }
///             
///             fn main() {
///                 let v = attach_iteration_counts! {
///                     ( hello ) ;
///                     ( indices , of ) ;
///                     () ;
///                     ( these, repetitions ) ;
///                 };
///                 println!("{v:?}");
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 【导入、导出宏】
/// 
///          前面提到宏名是按顺序解析的，所以从其它模块中导入宏时与导入函数、trait 的方式不太一样，宏导入导出用 #[macro_use] 和 #[macro_export]
/// 
/// 
/// 
/// #[macro_use]
/// 
///             
///         1、通过作用于模块的方式让模块内的宏的作用域在模块关闭时不结束
/// 
///
///             #![allow(unused)]
///             
///             #[macro_use]   // 加了这行，使之宏 m 在 mod inner 之外还有意义
///             mod inner {
///                 macro_rules! m {
///                     () => {};
///                 }
///             }
///             
///             fn main() {
///                 m!();
///             }
///         
/// 
///         2、用于从另一个 crate 里来导入宏，方法是将它附加到当前 crate 根模块中的 extern crate 声明前
/// 
///             (要用 #[macro_use] 导入宏，必须先使用 #[macro_export] 将被使用的宏导出)
/// 
///             #[macro_use(lazy_static)] // 或者使用 #[macro_use] 来导入所有宏.
///             extern crate lazy_static;
///             
///             lazy_static!{}
///             // self::lazy_static!{} // 报错: lazy_static 没在 `self` 中定义
/// 
/// 
/// 
/// 
/// 
/// 
/// #[macro_export]
/// 
///             【默认情况下，宏没有基于路径的作用域。】
///             
///             crate 之间只有被标为 #[macro_export] 的宏可以被其它 crate 导入。
/// 
///             宏带有 #[macro_export] 属性，则相当于它在  当前 crate 的  根作用域  的顶部被声明
/// 
///             (标有 #[macro_export] 的宏始终是 pub 的，以便可以通过  路径 (使用 use 类似引用其他对象一样引用) 或前面  所述的 #[macro_use] 方式让其他 crate 来引用)
/// 
/// 
/// 
///             #![allow(unused)]
///             
///             mod inner {
///                 super::m!();    // 由于 mod mac 将宏 m 导出到当前 crate 的顶部，(又 mod inner 的 super 是当前 main mod)，可以这样用 
///                 crate::m!();    // 由于 mod mac 将宏 m 导出到当前 crate 的顶部，可以这样用 
///             }
///             
///             mod mac {
///                 #[macro_export]     // 导出 宏 m 到当前  crate 的顶部声明
///                 macro_rules! m {
///                     () => {};
///                 }
///             }
///             
///             
///             fn main() {
///                 self::m!(); // 由于 mod mac 将宏 m 导出到当前 crate 的顶部，可以这样用 
///                 m!();       // OK: 基于路径的查找发现 m 在当前模块中有声明.
///             }
/// 
/// 
/// 
/// 
/// 
/// 【宏的  卫生性】    使用  $crate 查找宏
/// 
/// 
///     默认情况下： 
///                 宏中引用的所有标识符都按原样展开，并在宏的调用位置上去查找。
/// 
///     异常情况下：
///                 如果 宏引用 的 程序项 或 宏不在调用位置的作用域内，则这可能会导致问题。
/// 
/// 
///             // 在 `helper_macro` crate 中.
///             #[macro_export]
///             macro_rules! helped {
///                 // () => { helper!() } // 这可能会导致错误，因为 'helper' 在当前作用域之后才定义.
///                 () => { $crate::helper!() }
///             }
///             
///             #[macro_export]
///             macro_rules! helper {
///                 () => { () }
///             }
///             
///             // 在另一个 crate 中使用.
///             // 注意没有导入 `helper_macro::helper`!
///             use helper_macro::helped;
///             
///             fn unit() {
///                 helped!();
///             }
///             
/// 
/// 
///     【由于 $crate 指的是当前的（$crate 源码出现的）crate，因此在引用非宏程序项时，它必须与全限定模块路径一起使用】
///                 
///         
/// 
/// 
/// 
///             #![allow(unused)]
///             
///             
///             pub mod inner {
///             
///                 #[macro_export]                         // 导出宏 call_foo
///                 macro_rules! call_foo {
///             
///                     () => { $crate::inner::foo() };     // 从当前 crate  开始引用 mod inner 的 foo 函数
///             
///                 }
///             
///                 pub fn foo() {
///                     println!("hello foo");
///                 }
///             }
///             
///             #[macro_use(inner::call_foo)]               // 引用 mod inner 导出来的宏 call_foo
///             
///             fn main() {
///                 call_foo!();
///             }
/// 
/// 
/// 
/// 
/// 
///     【$crate 引用的 程序项 或者  宏， 必须在调用位置处可见， 即： $crate 受可见性条件约束】
/// 
/// 
///             
///             #![allow(unused)]
///             
///             
///             mod inner {
///                 #[macro_export]
///                 macro_rules! call_foo {
///                     () => { $crate::foo() };  // 因为 inner::foo 函数是 private 的，对于  crate 来说是不可以直接访问到的
///                 }
///                 
///                 fn foo() {
///                     println!("hello foo");
///                 }
///             }
///             
///             
///             fn main() {
///                 call_foo!();
///             }
///              
/// 
/// 
/// 
///     【当一个宏被导出时，可以在 #[macro_export] 属性里添加 local_inner_macros 属性值，用以自动为该属性修饰的宏内包含的所有宏调用自动添加 $crate:: 前缀】
/// 
/// 
/// 
/// 
/// 
///             #![allow(unused)]
///             
///             #[macro_export(local_inner_macros)]
///             macro_rules! helped {
///                 () => { helper!() } // 自动转码为 $crate::helper!().
///             }
///             
///             #[macro_export]
///             macro_rules! helper {
///                 () => { () ; println!("hello helper");}
///             }
///             
///             fn main() {
///                 helped!();
///             }
///             
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 【声明宏的缺点】
/// 
///             1、缺少对宏的自动完成和展开的支持
///             
///             2、声明式宏调式困难
///             
///             3、修改能力有限
///             
///             4、更大的二进制
///             
///             5、更长的编译时间 (这一条对于【声明宏】和【过程宏】都存在)
/// 
/// 
/// 
/// 
/// 
/// 
/// ######################################################################################################################################################
/// 过程宏 的 定义 及 使用
/// ###################################################################################################################################################### 
/// 
/// 
/// 过程宏接收一个 TokenStream 作为参数并返回另一个 TokenStream
/// 
/// 
/// 
///         1、类属性  宏（Attribute-like macros）
///         2、派生    宏（Derive macros）
///         3、类函数  宏（Function-like macros）
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 1、类属性  宏
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 
/// 类属性宏使你能够创建一个自定义的属性，将其附加到一个项目上，并允许对该项目进行操作.  它也可以接受参数.  
/// 
/// #[some_attribute_macro(some_argument)]    // some_attribute_macros 是一个类属性宏.  它操纵着函数 perform_task
/// fn perform_task(){
///     / some code
/// }
/// 
/// 
/// 
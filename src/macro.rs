/// -Z trace-macros
/// 
/// ######################################################################################################################################################
/// å®  çš„ å®šä¹‰ åŠ ä½¿ç”¨
/// 
/// rust çš„å®åŸºæœ¬æ˜¯  éƒ¨åˆ†å«ç”Ÿæ€§çš„
/// ###################################################################################################################################################### 
/// 
/// 1ã€ å£°æ˜å®ï¼š   ç¼–å†™ç±»ä¼¼äº match è¡¨è¾¾å¼
/// 2ã€ è¿‡ç¨‹å®ï¼š   å¯¹å®ƒæ‰€ç»™çš„ Rust ä»£ç çš„æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰è¿›è¡Œæ“ä½œï¼Œ å¦‚: #[derive(Debug)]
/// 
/// 
/// 
/// å®å±•å¼€ï¼š  rustc -Z unpretty=expanded ./src/main.rs  
/// 
/// å®è°ƒè¯•:   rustc -Z trace-macros ./src/main.rs  éœ€è¦é…åˆ #![feature(trace_macros)] ç”¨
/// 
/// 
/// ######################################################################################################################################################
/// ######################################################################################################################################################
/// ######################################################################################################################################################
/// 
///                                                                 å£°æ˜å® çš„ å®šä¹‰ åŠ ä½¿ç”¨
/// 
/// ######################################################################################################################################################
/// ######################################################################################################################################################
/// ###################################################################################################################################################### 
/// 
/// 
/// 
/// 
/// 
/// å®å®šä¹‰çš„å†…å®¹ç”± è§„åˆ™(rule) ç»„æˆ, æ¯ä¸€æ¡è§„åˆ™éƒ½å½¢å¦‚:
///
///  (Pattern) => { Exapnsion };
/// 
/// å…¶ä¸­æ‰€ä½¿ç”¨çš„çš„ æ‹¬å·  (), [], {} æ˜¯ä¸å—é™åˆ¶çš„, è°ƒç”¨æ—¶ä¸ä¼šå¯¹æ‹¬å·è¿›è¡Œæ£€æŸ¥.
/// 
/// () => {} çœ‹èµ·æ¥å¾ˆç¥ç§˜, å› ä¸ºå®ƒä¸æ˜¯æ ‡å‡†çš„ rust è¯­æ³•, æ˜¯ macro_rules! è¿™ä¸ªå®è‡ªå·±å‘æ˜çš„, ç”¨æ¥è¡¨ç¤ºä¸€æ¡å®è§„åˆ™:   "=>" å·¦è¾¹æ˜¯ã€åŒ¹é…æ¨¡å¼ã€‘, å³è¾¹æ˜¯ã€ç­‰å¾…å±•å¼€çš„ä»£ç ã€‘
/// 
/// ç±»ä¼¼äºRustä¸­çš„matchè¯­å¥, åœ¨macro_rules!ä¸­å¯ä»¥å®šä¹‰å¤šæ¡å®è§„åˆ™,  å½“å®è¢«è°ƒç”¨æ—¶, ä¼šç”±ä¸Šè€Œä¸‹å¯¹æ¯ä¸ªè§„åˆ™è¿›è¡ŒåŒ¹é…, å¦‚æœæŸä¸€æ¡è§„åˆ™ä¸è¾“å…¥ å®Œå…¨ åŒ¹é…, åˆ™ç«‹åˆ»è¿›è¡Œè¯¥è§„åˆ™æ‰€å¯¹åº”çš„å±•å¼€.
/// 
///
/// 
/// macro_rules! hey{
///     () => {}, 
///     () => {}
/// }
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// åˆå¦‚:
/// 
/// 
/// macro_rules! add{
///     // first arm match add!(1, 2),  add!(2, 3) etc
///        ($a:expr, $b:expr)=>{
///            {
///                $a+$b
///            }
///        };
///    // Second arm macth add!(1),  add!(2) etc
///        ($a:expr)=>{
///            {
///                $a
///            }
///        }
///    }
///    
///    fn main(){
/// 
///        let x=0;
/// 
///        add!(1, 2);   // åŒ¹é…åˆ° å®ä¸­ ç¬¬ä¸€ä¸ªè§„åˆ™
///        add!(x);     // åŒ¹é…åˆ° å®ä¸­ ç¬¬äºŒä¸ªè§„åˆ™
///    }
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// å®çš„å‚æ•°æè¿°ä¸º:  
/// 
///         **************************
///         *   $å‚æ•°åç§°: å‚æ•°ç±»å‹   *
///         **************************
/// 
/// å¦‚:         $a:expr
/// 
/// å‚æ•°ç±»å‹å«åš: é€‰æ‹©å™¨ã€tokenç±»å‹
/// 
/// 
/// 
/// 
/// ã€å‚æ•°ç±»å‹ã€‘
/// 
/// 
/// 
///         1ã€ item:           Item, å¦‚ï¼šå‡½æ•°å®šä¹‰, å¸¸é‡å£°æ˜, ç»“æ„ä½“, æ¨¡å—, impl å— ç­‰ç­‰
///         2ã€ block:          BlockExpression, ä¸€ä¸ªè¯­å¥å— æˆ– ä¸€ä¸ªè¡¨è¾¾å¼, ç”±èŠ±æ‹¬å·æ‰€åŒ…å›´, å¦‚: { ... }
///         3ã€ stmt:           Statement, è¯­å¥, å¦‚: let è¡¨è¾¾å¼ (ä¼ å…¥ä¸º stmt ç±»å‹çš„å‚æ•°æ—¶ ã€ä¸éœ€è¦æœ«å°¾çš„åˆ†å·ã€‘, ä½†éœ€è¦åˆ†å·çš„ item è¯­å¥é™¤å¤–)
///         4ã€ pat:            Pattern, æ¨¡å¼åŒ¹é…ä¸­çš„ ã€æ¨¡å¼ã€‘, å¦‚: Some(a)
///         5ã€ expr:           Expression, è¡¨è¾¾å¼, å¦‚: Vec::new()
///         6ã€ ty:             Type, ç±»å‹, å¦‚: i32
///         7ã€ ident:          IDENTIFIER_OR_KEYWORD, ã€æ ‡è¯†ç¬¦ã€‘ æˆ– ã€å…³é”®å­—ã€‘, å¦‚: i æˆ– self
///         8ã€ path:           TypePath, ç±»å‹è·¯å¾„, å¦‚: std::result::Result
///         9ã€ tt:             TokenTree, Token æ ‘ (å•æ£µæ ‡è®°æ ‘), è¢«åŒ¹é…çš„å®šç•Œç¬¦ (ã€[] æˆ– {} ä¸­çš„å•ä¸ªæˆ–å¤šä¸ª token  ã€ç†è®ºä¸Šå¯ä»¥åŒ¹é…æ‰€æœ‰ ...ã€‘
///         10ã€ meta:          Attr, å½¢å¦‚: #[...] å’Œ #![...] çš„å±æ€§å†…éƒ¨çš„å†…å®¹
///         11ã€ lifetime:      LIFETIME_TOKEN, ç”Ÿå‘½å‘¨æœŸ Token, å¦‚: 'fooã€'static
///         12ã€ vis:           Visibility, å¯èƒ½ä¸ºç©ºçš„ ã€å¯è§æ€§é™å®šç¬¦ã€‘, å¦‚: pubã€pub(in crate)
///         13ã€ literal:       LiteralExpression, ä¸€ä¸ªå­—é¢å€¼, å¦‚: "Hello World!"ã€3.14ã€'ğŸ¦€'
/// 
///     ã€å…¶ä¸­, tt ç±»å‹å¯ä»¥è¢«è§†ä¸º Rust å®çš„ Anyã€‘
///      
///     ã€æœ‰ä¸€ä¸ªç‰¹æ®Šçš„å…ƒå˜é‡å«åš $crate ï¼Œå®ƒç”¨æ¥æŒ‡ä»£å½“å‰ crateã€‘
/// 
/// 
/// å®è¿˜å¯¹ å„ç§ç±»å‹çš„å‚æ•°  æ•è·ä¹‹å  æ‰€å…è®¸çš„å†…å®¹  æ·»åŠ äº†é™åˆ¶, ä»¥é¿å…è¯­ä¹‰å†²çª:
/// 
/// 
/// 
///         1ã€ item: ä»»ä½•æ ‡è®°
///         2ã€ block: ä»»ä½•æ ‡è®°
///         3ã€ stmt: =>ã€;ã€,
///         4ã€ expr: =>ã€;ã€,
///         5ã€ pat: =>ã€,ã€=ã€|ã€if æˆ– in
///         6ã€ ty: {ã€[ã€=>ã€,ã€>ã€=ã€:ã€;ã€|ã€as æˆ– where
///         7ã€ ident: ä»»ä½•æ ‡è®°
///         8ã€ path: {ã€[ã€=>ã€,ã€>ã€=ã€:ã€;ã€|ã€as æˆ– where
///         9ã€ meta: ä»»ä½•æ ‡è®°
///         10ã€ tt: ä»»ä½•æ ‡è®°
/// 
/// 
/// 
/// ã€é‡å¤æ¨¡å¼ã€‘
/// 
/// 
///         *****************************************************************************
///         *       $( éœ€è¦é‡å¤çš„å†…å®¹ )      [å¯é€‰çš„]åˆ†éš”ç¬¦          [å¿…é€‰çš„]é‡å¤æ ‡å¿—   *
///         *                                                                           *
///         *  å³ï¼š $( ... )                  sep                        rep            *
///         *****************************************************************************
/// 
/// sep    å¯é€‰çš„åˆ†éš”ç¬¦:        å¸¸è§çš„æœ‰ , å’Œ ;
/// 
/// rep    å¿…é€‰çš„é‡å¤æ ‡è®°:      ä¸‰ç§     * (0 åˆ° n æ¬¡)       + ( 1 åˆ° næ¬¡)        ? (æœ€å¤šä¸€æ¬¡  ï¼Œæ‰€ä»¥æ­¤æ—¶ä¸èƒ½å‰è·Ÿåˆ†éš”æ ‡è®°)
/// 
/// å¦‚:
///         $( $i:expr ),
///         $( $i:expr, )*
///         $( $i:expr ),* $(,)?
/// 
/// 
/// å¦‚ä¸‹:
/// 
/// 
///          å…¥é›¶ä¸ªæˆ–å¤šä¸ªç›¸åŒç±»å‹çš„å€¼, æ„é€ ä¸€ä¸ªåŒ…å«è¿™äº›å€¼ï¼ˆæŒ‰ç…§é¡ºåºï¼‰çš„ Vec.
///        
///          macro_rules! build_vec {
///              (
///                  $( $i:expr ),*                          // é‡å¤, ä»¥æ”¯æŒä»»æ„æ•°é‡çš„å‚æ•°
///                  $(,)?                                   // å¯é€‰çš„æœ«å°¾é€—å·
///              ) => {
///                  {                                       // åˆ›å»ºä¸€ä¸ªå—, ä»¥æ”¯æŒå¤šæ¡è¯­å¥
///                      let mut vec = Vec::new();           // æ„é€ ä¸€ä¸ª Vec, å¿…é¡»ä¸º mut, å¦åˆ™ä¸‹æ–‡æ— æ³•è¿›è¡Œ push
///          
///                      $(                                  // é‡å¤, å°†æ¯ä¸ª $i æ¨å…¥ vec ä¸­
///                          vec.push($i);
///                      )*
///          
///                      vec                                 // è¿”å› vec
///                  }
///              }
///          }
///        
/// ----------------------------------------------------------------------------------------------
/// 
/// åˆå¦‚:
/// 
/// 
///          macro_rules! add{
///  
///              // å•å‚æ•°æƒ…å†µä¸‹
///                 ($a:expr)=>{
///                     $a
///                 };
///  
///             // åœ¨ä¼ é€’ä¸¤ä¸ªå‚æ•°çš„æƒ…å†µä¸‹
///                 ($a:expr,$b:expr)=>{
///                     {
///                         $a+$b
///                     }
///                 };
///  
///             // ä½¿ç”¨å…¶ä»–å‚æ•°å†æ¬¡è°ƒç”¨ add å®
///                 ($a:expr,$($b:tt)*)=>{
///                    {
///                        $a+add!($($b)*)
///                    }
///                 }
///             }
///             
///             fn main(){
///               println!("{}",add!(1,2,3,4));
///             }
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// åˆå¦‚:
/// 
/// 
/// 
/// 
///             macro_rules! make_public{
///                 (
///                  $(#[$meta:meta])*
///                  $vis:vis struct $struct_name:ident {
///                     $(
///                     $(#[$field_meta:meta])*
///                     $field_vis:vis $field_name:ident : $field_type:ty
///                     ),*$(,)+
///                 }
///                 ) => {
///             
///                         $(#[$meta])*
///                         pub struct $struct_name{
///                             $(
///                             $(#[$field_meta:meta])*
///                             pub $field_name : $field_type,
///                             )*
///                         }
///                 }
///             }
///             
///             fn main(){
///                 make_public!{
///                     #[derive(Debug)]
///                     struct Name{
///                         n:i64,
///                         t:i64,
///                         g:i64,
///                     }
///                 }
///             
///                 // å¾—åˆ°ï¼š
///                 // #[derive(Debug)]
///                 // pub struct name {
///                 //     pub n: i64,
///                 //     pub t: i64,
///                 //     pub g: i64,
///                 // }
///             }
///             
///             
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 
/// 
/// ã€å…ƒå˜é‡è¡¨è¾¾å¼ã€‘
/// 
/// 
/// Rust æœ‰ä¸€äº›ç‰¹æ®Šçš„å…ƒå˜é‡è¡¨è¾¾å¼ï¼ˆä»¥ä¸‹ç®€ç§°è¡¨è¾¾å¼ï¼‰ï¼štranscriber (è½¬ç å™¨) å¯ä»¥ä½¿ç”¨è¿™äº›è¡¨è¾¾å¼æ¥è·å–æœ‰å…³å…ƒå˜é‡çš„ä¿¡æ¯
/// 
/// 
///             1. $$ï¼š                         å±•å¼€ä¸ºå•ä¸ª $ï¼Œè¿™ä¼šæœ‰æ•ˆåœ°è½¬ä¹‰ $ æ ‡è®°ï¼Œå› æ­¤å®ƒä¸ä¼šè¢«å±•å¼€ (è½¬ç )
///             2. ${count($ident)}ï¼š           ã€æœ€é‡Œã€‘å±‚ $ident æ€»å…±é‡å¤çš„æ¬¡æ•°ï¼Œç›¸å½“äº ${count(ident, 0)}
///             3. ${count($identï¼Œdepth)}ï¼š    ç¬¬ depth å±‚ $ident æ€»å…±é‡å¤çš„æ¬¡æ•°
///             4. ${index()}ï¼š                 ã€æœ€é‡Œã€‘å±‚é‡å¤çš„å½“å‰é‡å¤çš„ç´¢å¼•ï¼Œç›¸å½“äº ${index(0)}
///             5. ${index(depth)}ï¼š            åœ¨ç¬¬ depth å±‚å¤„å½“å‰é‡å¤çš„ç´¢å¼•ï¼Œå‘å¤–è®¡æ•°
///             6. ${len()}ï¼š                   ã€æœ€é‡Œã€‘å±‚é‡å¤çš„ã€é‡å¤æ¬¡æ•°ã€‘ï¼Œç›¸å½“äº ${length(0)}
///             7. ${len(depth)}ï¼š              åœ¨ç¬¬ depth å±‚é‡å¤çš„æ¬¡æ•°ï¼Œå‘å¤–è®¡æ•°
///             8. ${ignore(ident)}ï¼š           ç»‘å®š $ident è¿›è¡Œé‡å¤ï¼Œå¹¶å±•å¼€æˆç©º
///         
/// 
/// 
///     1. ã€$$ã€‘
/// 
///     é”™è¯¯ç¤ºä¾‹: (ä¸ç”¨ $$ æ—¶)
/// 
///             macro_rules! foo {
///                 () => {
///                     macro_rules! bar {
///                         ( $( $any:tt )* ) => { $( $any )* };    
///                         // ^^^^^^^^^^^ error: attempted to repeat an expression containing no syntax variables matched as repeating at this depth
///                         //
///                         // foo! çš„ transcriber çœ‹åˆ°æœ‰é‡å¤æ•è·çš„æ„å›¾ï¼Œå¹¶è¯•å›¾é‡å¤æ•è·ï¼Œä½†å®ƒçš„ä½œç”¨åŸŸä¸­æ²¡æœ‰ $any å…ƒå˜é‡ï¼Œè¿™å¯¼è‡´å®ƒäº§ç”Ÿé”™è¯¯.
///                         // å³åœ¨ foo ä¸­æ²¡æœ‰ $any å…ƒå˜é‡ï¼Œåˆ™åœ¨ bar ä¸­ä½¿ç”¨ï¼Œåˆ™é”™è¯¯
///                     }
///                 };
///             }
///             
///             fn main() {
///                 foo!();
///             }
/// 
/// 
/// 
///     æ­£ç¡®ç¤ºä¾‹:  (ä½¿ç”¨ $$ æ—¶)
/// 
///             #![feature(macro_metavar_expr)]
///             
///             macro_rules! foo {
///                 () => {
///                     macro_rules! bar {
///                         ( $$( $$any:tt )* ) => { $$( $$any )* };
///                     }
///                 };
///             }
///             
///             fn main() {
///                 foo!();
///                 bar!();
///             }
/// 
/// 
/// 
///         
///     2. ã€${count($ident)}ã€‘ å’Œ ã€${count($identï¼Œdepth)}ã€‘
/// 
///         
/// 
///         count è¡¨è¾¾å¼å±•å¼€æˆå…ƒå˜é‡ $ident åœ¨ç»™å®šé‡å¤æ·±åº¦çš„é‡å¤æ¬¡æ•°ã€‚
/// 
///         
///         
///                 $ident å‚æ•°å¿…é¡»æ˜¯è§„åˆ™ä½œç”¨åŸŸä¸­å£°æ˜çš„å…ƒå˜é‡
///                 depth å‚æ•°å¿…é¡»æ˜¯å€¼ <= å…ƒå˜é‡ $ident å‡ºç°çš„æœ€å¤§é‡å¤æ·±åº¦çš„æ•´å‹å­—é¢å€¼
///                 count($ident, depth) å±•å¼€æˆä¸å¸¦åç¼€çš„æ•´å‹å­—é¢å€¼æ ‡è®°
///                 count($ident) æ˜¯ count($ident, 0) çš„ç®€å†™; å³ï¼š ${count($ident)} ç›¸å½“äº ${count($identï¼Œ0)}
/// 
/// 
///         ä¾‹å¦‚:  
///         
///                 ${count(x)} $( $x )*  
///         
///         è¡¨è¾¾å¼ ${count(x)} å°†æ‰©å±•ä¸ºæ— åç¼€çš„æ•´æ•°æ–‡å­—ï¼Œç­‰äº $( $x )* é‡å¤çš„é‡å¤æ¬¡æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå…ƒå˜é‡ $x é‡å¤å››æ¬¡ï¼Œé‚£ä¹ˆå®ƒå°†æ‰©å±•åˆ°æ•´æ•°æ–‡å­— 4
/// 
///         å¦‚æœé‡å¤æ˜¯åµŒå¥—çš„ï¼Œåˆ™å¯ä»¥ä½¿ç”¨å¯é€‰çš„æ·±åº¦å‚æ•°æ¥é™åˆ¶è®¡ç®—çš„åµŒå¥—é‡å¤çš„æ•°é‡ã€‚ä¾‹å¦‚ï¼Œå®æ‰©å±•å¦‚ä¸‹ï¼š
/// 
///                 ${count(x, 1)} ${count(x, 2)} ${count(x, 3)} $( a $( b $( $x )* )* )*
/// 
///         æ‰©å±•ä¸ºçš„ä¸‰ä¸ªå€¼æ˜¯æœ€å¤–å±‚é‡å¤æ¬¡æ•°ï¼ˆ a ç”Ÿæˆçš„æ¬¡æ•°ï¼‰ã€ä¸­é—´é‡å¤æ¬¡æ•°çš„æ€»å’Œï¼ˆ b ç”Ÿæˆçš„æ¬¡æ•°ï¼‰ä»¥åŠ $x çš„é‡å¤æ€»æ•°
/// 
///     
/// 
///             #![feature(macro_metavar_expr)]
///             
///             macro_rules! foo {
///                 ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {
///                     println!("count(outer, 0): $outer repeats {} times", ${count($outer)});                                             // 4
///                     println!("count(inner, 0): The $inner repetition repeats {} times in the outer repetition", ${count($inner, 0)});   // 3
///                     println!("count(inner, 1): $inner repeats {} times in the inner repetitions", ${count($inner, 1)});                 // 4
///                 };
///             }
///             
///             fn main() {
///                 foo! {
///                     outer () ;
///                     outer ( inner , inner ) ;
///                     outer () ;
///                     outer ( inner ) ;
///                 };
///             }
/// 
/// 
/// 
///     3. ã€${index()}ã€‘å’Œã€${index(depth)}ã€‘
/// 
///         index(depth) è¡¨è¾¾å¼å±•å¼€ä¸ºç»™å®šé‡å¤æ·±åº¦ä¸‹ï¼Œå½“å‰çš„è¿­ä»£ç´¢å¼•ã€‚
///             
///             depth å‚æ•°è¡¨æ˜åœ¨ç¬¬å‡ å±‚é‡å¤ï¼Œè¿™ä¸ªæ•°å­—  ä»æœ€å†…å±‚é‡å¤ è°ƒç”¨è¡¨è¾¾å¼å¼€å§‹ å‘å¤– è®¡ç®—
///             index(depth) å±•å¼€æˆä¸å¸¦åç¼€çš„æ•´å‹å­—é¢å€¼æ ‡è®°
///             index() æ˜¯ index(0) çš„ç®€å†™
/// 
/// 
/// 
/// 
/// 
/// 
///             #![feature(macro_metavar_expr)]
///             //
///             // (("hello", 0, 0), ("indices", 1, 0), ("of", 1, 1), ("these", 3, 0), ("repetitions", 3, 1))
///             //
///             macro_rules! attach_iteration_counts {
///                 ( $( ( $( $inner:ident ),* ) ; )* ) => {
///                     ( $(
///                         $((
///                             stringify!($inner),
///                             ${index(1)},        // è¿™æŒ‡çš„æ˜¯å¤–å±‚é‡å¤
///                             ${index()}          // è¿™æŒ‡çš„æ˜¯å†…å±‚é‡å¤ï¼Œç­‰ä»·äº `index(0)`
///                         ),)*
///                     )* )
///                 };
///             }
///             
///             fn main() {
///                 let v = attach_iteration_counts! {
///                     ( hello ) ;                     // hello åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 0, åœ¨ ${index()} å±‚çš„ç´¢å¼•ä¸º 0
///                     ( indices , of ) ;              // indices åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 1, åœ¨ ${index()} å±‚çš„ç´¢å¼•ä¸º 0 ï¼› of åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 1, åœ¨ ${index()} å±‚çš„ç´¢å¼•ä¸º 1
///                     () ;                            // æ²¡æœ‰å…ƒç´  $inner ï¼Œæ•…ä¸æ‰“å°
///                     ( these, repetitions ) ;        // these åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 3, åœ¨ ${index()} å±‚çš„ç´¢å¼•ä¸º 0 ; repetitions åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 3, åœ¨ ${index()} å±‚çš„ç´¢å¼•ä¸º 1
///                 };
///                 println!("{v:?}");
///             }
/// 
/// 
/// 
///             å°çŸ¥è¯†: 
/// 
///                     stringify! æ˜¯ Rust æä¾›çš„å†…ç½®å®ï¼Œå¯ä»¥å°†ä¸€ä¸ªè¡¨è¾¾å¼(ä¾‹å¦‚ 1 + 2) åœ¨ ã€ç¼–è¯‘æœŸã€‘ è½¬æ¢æˆä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢å€¼("1 + 2")ï¼Œ
///                     è¯¥å­—é¢é‡ä¼šç›´æ¥æ‰“åŒ…è¿›ç¼–è¯‘å‡ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå…·æœ‰ 'static ç”Ÿå‘½å‘¨æœŸã€‚
///                     
///                     ä½¿ç”¨ stringify! æœ‰ä¸¤ä¸ªå¥½å¤„:
///                     
///                                             1. å…¥å‚å¯èƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦å®ƒçš„å­—é¢å€¼å½¢å¼
/// 
///                                             2. å¯ä»¥å‡å°‘ä¸€æ¬¡ String å¸¦æ¥çš„å†…å­˜åˆ†é… (åœ¨ç¼–è¯‘å™¨ç¼–è¯‘å­—é¢é‡åˆ°äºŒè¿›åˆ¶ä¸­äº† ...)
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///     4. ã€${len()}ã€‘ å’Œ ã€${len(depth)}ã€‘
/// 
///         length(depth) è¡¨è¾¾å¼å±•å¼€ä¸ºåœ¨ç»™å®šé‡å¤æ·±åº¦çš„è¿­ä»£æ¬¡æ•°ã€‚
///             
///             depth å‚æ•°è¡¨ç¤ºåœ¨ç¬¬å‡ å±‚é‡å¤ï¼Œè¿™ä¸ªæ•°å­—ä»æœ€å†…å±‚é‡å¤è°ƒç”¨è¡¨è¾¾å¼å¼€å§‹å‘å¤–è®¡ç®—
///             length(depth) å±•å¼€æˆä¸å¸¦åç¼€çš„æ•´å‹å­—é¢å€¼æ ‡è®°
///             length() æ˜¯ length(0) çš„ç®€å†™
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///             #![feature(macro_metavar_expr)]
///             //
///             // 'small' in inner iteration 0/2 with 'many' in outer iteration 0/3 
///             // 'things' in inner iteration 1/2 with 'many' in outer iteration 0/3 
///             // 'one' in inner iteration 0/1 with 'exactly' in outer iteration 2/3 
///             //
///             macro_rules! lets_count {
///                 ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {
///                     $(
///                         $(
///                             println!(
///                                 "'{}' in inner iteration {}/{} with '{}' in outer iteration {}/{} ",
///                                 stringify!($inner), ${index()}, ${len()},
///                                 stringify!($outer), ${index(1)}, ${len(1)},
///                             );
///                         )*
///                     )*
///                 };
///             }
///             
///             fn main() {
///                 lets_count!(
/// 
///                     // small åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 0, è€Œå½“å‰é‡Œå±‚å…ƒç»„çš„é•¿åº¦ ${len()} ä¸º 2; things åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 1, è€Œå½“å‰é‡Œå±‚å…ƒç»„çš„é•¿åº¦ ${len()} ä¸º 2;
///                     // many  åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 0ï¼Œè€Œå½“å‰å¤–å±‚å…ƒç»„çš„é•¿åº¦ ${len(1) ä¸º 3
///                     many (small , things) ; 
/// 
///                     // ç”±äºæ²¡æœ‰é‡Œå±‚å…ƒç»„ï¼Œåˆ™ç›´æ¥ä¸æ‰“å°äº† ...    
///                     none () ;
/// 
///                     // one åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 0, è€Œå½“å‰é‡Œå±‚å…ƒç»„çš„é•¿åº¦ ${len()} ä¸º 1
///                     // exactly  åœ¨ ${index(1)} å±‚ç´¢å¼•ä¸º 2ï¼Œè€Œå½“å‰å¤–å±‚å…ƒç»„çš„é•¿åº¦ ${len(1) ä¸º 3
///                     exactly ( one ) ;
///                 );
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///     5. ã€${ignore(ident)}ã€‘
/// 
///         ignore(ident) è¡¨è¾¾å¼å±•å¼€ä¸ºç©ºï¼Œè¿™ä½¿å¾—åœ¨æ— éœ€å®é™…å±•å¼€å…ƒå˜é‡çš„æ—¶å€™ï¼Œåƒå…ƒå˜é‡é‡å¤å±•å¼€ç›¸åŒæ¬¡æ•°çš„æŸäº›å†…å®¹
///             
///             ident å‚æ•°å¿…é¡»æ˜¯è§„åˆ™ä½œç”¨åŸŸä¸­å£°æ˜çš„å…ƒå˜é‡
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///             #![feature(macro_metavar_expr)]
///             //
///             // ((0, 0), (1, 0), (0, 2), (0, 3), (1, 3), (2, 3))
///             //
///             macro_rules! repetition_tuples {
///                 ( $( ( $( $inner:ident ),* ) ; )* ) => {
///                     ($(
///                         $(
///                             (
///                                 ${index()},
///                                 ${index(1)}
///                                 ${ignore($inner)} // without this metavariable expression, compilation would fail    å¦‚æœæ²¡æœ‰è¿™ä¸ªå…ƒå˜é‡è¡¨è¾¾å¼ï¼Œç¼–è¯‘å°±ä¼šå¤±è´¥
///                                 
///                                 // ä¸Šè¿°å’Œä»¥ä¸‹ç±»ä¼¼:
///                                 //
///                                 //  stringify!($inner),
///                                 //  ${index(1)},        // è¿™æŒ‡çš„æ˜¯å¤–å±‚é‡å¤
///                                 //  ${index()}          // è¿™æŒ‡çš„æ˜¯å†…å±‚é‡å¤ï¼Œç­‰ä»·äº `index(0)`
///                                 //
///                                 // åªä¸è¿‡äººå®¶ stringify!($inner) æ˜¯å­—ç¬¦æ‹¼æ¥ $inner ï¼Œè€Œ ${ignore($inner)} æ˜¯å¿½ç•¥æ‰ $inner
///                             ),
///                         )*
///                     )*)
///                 };
///             }
///             
///             fn main() {
///                 let tuple = repetition_tuples!(
///                     
///                     // one åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 0, åœ¨ ${index(1)} å±‚çš„ç´¢å¼•ä¸º 0, ignore æ‰ $inner æ•…: (0, 0) 
///                     // two åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 1, åœ¨ ${index(1)} å±‚çš„ç´¢å¼•ä¸º 0, ignore æ‰ $inner æ•…: (1, 0)
///                     ( one, two ) ;   
///                     
///                     // æ²¡æœ‰å…ƒç´  $inner ï¼Œæ•…ä¸æ‰“å°             
///                     () ;
///                     
///                     // one åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 0, åœ¨ ${index(1)} å±‚çš„ç´¢å¼•ä¸º 2, ignore æ‰ $inner æ•…: (0, 2) 
///                     ( one ) ;
///                     
///                     // one åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 0, åœ¨ ${index(1)} å±‚çš„ç´¢å¼•ä¸º 3, ignore æ‰ $inner æ•…: (0, 3) 
///                     // one åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 1, åœ¨ ${index(1)} å±‚çš„ç´¢å¼•ä¸º 3, ignore æ‰ $inner æ•…: (1, 3) 
///                     // one åœ¨ ${index()} å±‚ç´¢å¼•ä¸º 2, åœ¨ ${index(1)} å±‚çš„ç´¢å¼•ä¸º 3, ignore æ‰ $inner æ•…: (2, 3) 
///                     ( one, two, three ) ;
///                 );
///                 println!("{tuple:?}");
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// ã€å¯¼å…¥ã€å¯¼å‡ºå®ã€‘
/// 
///          å‰é¢æåˆ°å®åæ˜¯æŒ‰é¡ºåºè§£æçš„ï¼Œæ‰€ä»¥ä»å…¶å®ƒæ¨¡å—ä¸­å¯¼å…¥å®æ—¶ä¸å¯¼å…¥å‡½æ•°ã€trait çš„æ–¹å¼ä¸å¤ªä¸€æ ·ï¼Œå®å¯¼å…¥å¯¼å‡ºç”¨ #[macro_use] å’Œ #[macro_export]
/// 
/// 
/// 
/// #[macro_use]
/// 
///             
///         1ã€å¯¼å‡ºè¯¥æ¨¡å—å†…çš„æ‰€æœ‰å®ï¼Œ ä»è€Œè®©å¯¼å‡ºçš„å®åœ¨æ‰€å®šä¹‰çš„æ¨¡å—ç»“æŸä¹‹åä¾ç„¶å¯ç”¨
/// 
///
///             #![allow(unused)]
///             
///             #[macro_use]   // åŠ äº†è¿™è¡Œï¼Œä½¿ä¹‹å® m åœ¨ mod inner ä¹‹å¤–è¿˜æœ‰æ„ä¹‰
///             mod inner {
///                 macro_rules! m {
///                     () => {};
///                 }
///             }
///             
///             fn main() {
///                 m!();
///             }
///         
/// 
///         2ã€ç”¨äºä»å¦ä¸€ä¸ª crate é‡Œæ¥å¯¼å…¥å®ï¼Œæ–¹æ³•æ˜¯å°†å®ƒé™„åŠ åˆ°å½“å‰ crate æ ¹æ¨¡å—ä¸­çš„ extern crate å£°æ˜å‰
/// 
///             (è¦ç”¨ #[macro_use] å¯¼å…¥å®ï¼Œå¿…é¡»å…ˆä½¿ç”¨ #[macro_export] å°†è¢«ä½¿ç”¨çš„å®å¯¼å‡º)
/// 
///             #[macro_use(lazy_static)] // æˆ–è€…ä½¿ç”¨ #[macro_use] æ¥å¯¼å…¥æ‰€æœ‰å®.
///             extern crate lazy_static;
///             
///             lazy_static!{}
///             // self::lazy_static!{} // æŠ¥é”™: lazy_static æ²¡åœ¨ `self` ä¸­å®šä¹‰
/// 
/// 
/// 
/// 
/// 
/// 
/// #[macro_export]
/// 
///             ã€é»˜è®¤æƒ…å†µä¸‹ï¼Œå®æ²¡æœ‰åŸºäºè·¯å¾„çš„ä½œç”¨åŸŸã€‚ã€‘
///             
///             crate ä¹‹é—´åªæœ‰è¢«æ ‡ä¸º #[macro_export] çš„å®å¯ä»¥è¢«å…¶å®ƒ crate å¯¼å…¥ã€‚
/// 
///             å®å¸¦æœ‰ #[macro_export] å±æ€§ï¼Œåˆ™ç›¸å½“äºå®ƒåœ¨  å½“å‰ crate çš„  æ ¹ä½œç”¨åŸŸ  çš„é¡¶éƒ¨è¢«å£°æ˜
/// 
///             (æ ‡æœ‰ #[macro_export] çš„å®å§‹ç»ˆæ˜¯ pub çš„ï¼Œä»¥ä¾¿å¯ä»¥é€šè¿‡  è·¯å¾„ (ä½¿ç”¨ use ç±»ä¼¼å¼•ç”¨å…¶ä»–å¯¹è±¡ä¸€æ ·å¼•ç”¨) æˆ–å‰é¢  æ‰€è¿°çš„ #[macro_use] æ–¹å¼è®©å…¶ä»– crate æ¥å¼•ç”¨)
/// 
/// 
/// 
///             #![allow(unused)]
///             
///             mod inner {
///                 super::m!();    // ç”±äº mod mac å°†å® m å¯¼å‡ºåˆ°å½“å‰ crate çš„é¡¶éƒ¨ï¼Œ(åˆ mod inner çš„ super æ˜¯å½“å‰ main mod)ï¼Œå¯ä»¥è¿™æ ·ç”¨ 
///                 crate::m!();    // ç”±äº mod mac å°†å® m å¯¼å‡ºåˆ°å½“å‰ crate çš„é¡¶éƒ¨ï¼Œå¯ä»¥è¿™æ ·ç”¨ 
///             }
///             
///             mod mac {
///                 #[macro_export]     // å¯¼å‡º å® m åˆ°å½“å‰  crate çš„é¡¶éƒ¨å£°æ˜
///                 macro_rules! m {
///                     () => {};
///                 }
///             }
///             
///             
///             fn main() {
///                 self::m!(); // ç”±äº mod mac å°†å® m å¯¼å‡ºåˆ°å½“å‰ crate çš„é¡¶éƒ¨ï¼Œå¯ä»¥è¿™æ ·ç”¨ 
///                 m!();       // OK: åŸºäºè·¯å¾„çš„æŸ¥æ‰¾å‘ç° m åœ¨å½“å‰æ¨¡å—ä¸­æœ‰å£°æ˜.
///             }
/// 
/// 
/// 
/// 
/// 
/// ã€å®çš„  å«ç”Ÿæ€§ã€‘    ä½¿ç”¨  $crate æŸ¥æ‰¾å®
/// 
/// 
///     é»˜è®¤æƒ…å†µä¸‹ï¼š 
///                 å®ä¸­å¼•ç”¨çš„æ‰€æœ‰æ ‡è¯†ç¬¦éƒ½æŒ‰åŸæ ·å±•å¼€ï¼Œå¹¶åœ¨å®çš„è°ƒç”¨ä½ç½®ä¸Šå»æŸ¥æ‰¾ã€‚
/// 
///     å¼‚å¸¸æƒ…å†µä¸‹ï¼š
///                 å¦‚æœ å®å¼•ç”¨ çš„ ç¨‹åºé¡¹ æˆ– å®ä¸åœ¨è°ƒç”¨ä½ç½®çš„ä½œç”¨åŸŸå†…ï¼Œåˆ™è¿™å¯èƒ½ä¼šå¯¼è‡´é—®é¢˜ã€‚
/// 
/// 
///             // åœ¨ `helper_macro` crate ä¸­.
///             #[macro_export]
///             macro_rules! helped {
///                 // () => { helper!() } // è¿™å¯èƒ½ä¼šå¯¼è‡´é”™è¯¯ï¼Œå› ä¸º 'helper' åœ¨å½“å‰ä½œç”¨åŸŸä¹‹åæ‰å®šä¹‰.
///                 () => { $crate::helper!() }
///             }
///             
///             #[macro_export]
///             macro_rules! helper {
///                 () => { () }
///             }
///             
///             // åœ¨å¦ä¸€ä¸ª crate ä¸­ä½¿ç”¨.
///             // æ³¨æ„æ²¡æœ‰å¯¼å…¥ `helper_macro::helper`!
///             use helper_macro::helped;
///             
///             fn unit() {
///                 helped!();
///             }
///             
/// 
/// 
///     ã€ç”±äº $crate æŒ‡çš„æ˜¯å½“å‰çš„ï¼ˆ$crate æºç å‡ºç°çš„ï¼‰crateï¼Œå› æ­¤åœ¨å¼•ç”¨éå®ç¨‹åºé¡¹æ—¶ï¼Œå®ƒå¿…é¡»ä¸å…¨é™å®šæ¨¡å—è·¯å¾„ä¸€èµ·ä½¿ç”¨ã€‘
///                 
///         
/// 
/// 
/// 
///             #![allow(unused)]
///             
///             
///             pub mod inner {
///             
///                 #[macro_export]                         // å¯¼å‡ºå® call_foo
///                 macro_rules! call_foo {
///             
///                     () => { $crate::inner::foo() };     // ä»å½“å‰ crate  å¼€å§‹å¼•ç”¨ mod inner çš„ foo å‡½æ•°
///             
///                 }
///             
///                 pub fn foo() {
///                     println!("hello foo");
///                 }
///             }
///             
///             #[macro_use(inner::call_foo)]               // å¼•ç”¨ mod inner å¯¼å‡ºæ¥çš„å® call_foo
///             
///             fn main() {
///                 call_foo!();
///             }
/// 
/// 
/// 
/// 
/// 
///     ã€$crate å¼•ç”¨çš„ ç¨‹åºé¡¹ æˆ–è€…  å®ï¼Œ å¿…é¡»åœ¨è°ƒç”¨ä½ç½®å¤„å¯è§ï¼Œ å³ï¼š $crate å—å¯è§æ€§æ¡ä»¶çº¦æŸã€‘
/// 
/// 
///             
///             #![allow(unused)]
///             
///             
///             mod inner {
///                 #[macro_export]
///                 macro_rules! call_foo {
///                     () => { $crate::foo() };  // å› ä¸º inner::foo å‡½æ•°æ˜¯ private çš„ï¼Œå¯¹äº  crate æ¥è¯´æ˜¯ä¸å¯ä»¥ç›´æ¥è®¿é—®åˆ°çš„
///                 }
///                 
///                 fn foo() {
///                     println!("hello foo");
///                 }
///             }
///             
///             
///             fn main() {
///                 call_foo!();
///             }
///              
/// 
/// 
/// 
///     ã€å½“ä¸€ä¸ªå®è¢«å¯¼å‡ºæ—¶ï¼Œå¯ä»¥åœ¨ #[macro_export] å±æ€§é‡Œæ·»åŠ  local_inner_macros å±æ€§å€¼ï¼Œç”¨ä»¥è‡ªåŠ¨ä¸ºè¯¥å±æ€§ä¿®é¥°çš„å®å†…åŒ…å«çš„æ‰€æœ‰å®è°ƒç”¨è‡ªåŠ¨æ·»åŠ  $crate:: å‰ç¼€ã€‘
/// 
/// 
/// 
/// 
/// 
///             #![allow(unused)]
///             
///             #[macro_export(local_inner_macros)]
///             macro_rules! helped {
///                 () => { helper!() } // è‡ªåŠ¨è½¬ç ä¸º $crate::helper!().
///             }
///             
///             #[macro_export]
///             macro_rules! helper {
///                 () => { () ; println!("hello helper");}
///             }
///             
///             fn main() {
///                 helped!();
///             }
///             
/// 
/// 
/// 
/// 
/// ã€ç¤ºä¾‹ã€‘ ä½¿ç”¨ å«ç”Ÿå® å®ç° æ–æ³¢é‚£å¥‘æ•°åˆ—
/// 
/// 
/// 
/// 
/// 
///             #[macro_export] // å¯¼å‡º
///             macro_rules! count_exprs {
///                 () => (0);
///                 ($head:expr) => (1);
///                 ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));
///             }
///             
///             #[macro_export] // å¯¼å‡º
///             macro_rules! recurrence {
///                 ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {
///             //    ^~~~~~~~~~   ^~~~~~~~~~ changed
///                     {
///                         use std::ops::Index;
///                         use $crate::count_exprs; // å¯¼å…¥
///             
///                         const MEM_SIZE: usize = count_exprs!($($inits),+);
///             
///                         struct Recurrence {
///                             mem: [$sty; MEM_SIZE],
///                             pos: usize,
///                         }
///             
///                         struct IndexOffset<'a> {
///                             slice: &'a [$sty; MEM_SIZE],
///                             offset: usize,
///                         }
///             
///                         impl<'a> Index<usize> for IndexOffset<'a> {
///                             type Output = $sty;
///             
///                             #[inline(always)]
///                             fn index<'b>(&'b self, index: usize) -> &'b $sty {
///                                 use std::num::Wrapping;
///             
///                                 let index = Wrapping(index);
///                                 let offset = Wrapping(self.offset);
///                                 let window = Wrapping(MEM_SIZE);
///             
///                                 let real_index = index - offset + window;
///                                 &self.slice[real_index.0]
///                             }
///                         }
///             
///                         impl Iterator for Recurrence {
///                             type Item = $sty;
///             
///                             #[inline]
///                             fn next(&mut self) -> Option<$sty> {
///                                 if self.pos < MEM_SIZE {
///                                     let next_val = self.mem[self.pos];
///                                     self.pos += 1;
///                                     Some(next_val)
///                                 } else {
///                                     let next_val = {
///                                         let $ind = self.pos;
///             //                              ^~~~ changed
///                                         let $seq = IndexOffset { slice: &self.mem, offset: $ind };
///             //                              ^~~~ changed
///                                         $recur
///                                     };
///             
///                                     {
///                                         use std::mem::swap;
///             
///                                         let mut swap_tmp = next_val;
///                                         for i in (0..MEM_SIZE).rev() {
///                                             swap(&mut swap_tmp, &mut self.mem[i]);
///                                         }
///                                     }
///             
///                                     self.pos += 1;
///                                     Some(next_val)
///                                 }
///                             }
///                         }
///             
///                         Recurrence { mem: [$($inits),+], pos: 0 }
///                     }
///                 };
///             }
///             
///             fn main() {
///                 // let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-1] + a[n-2]];
///                 // 
///                 // for e in fib.take(10) { println!("{}", e) }
///             
///                 for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {
///                     println!("{}", e)
///                 }
///                 
///             }
///             
///             
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// --------------------------------------- trace è°ƒè¯•å® -------------------------------------------------
///             
///             #![feature(trace_macros)]
///             
///             macro_rules! each_tt {
///                 () => {};
///                 ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);};
///             }
///             
///             fn main () {
///                 each_tt!(foo bar baz quux);
///                 trace_macros!(true);
///                 each_tt!(spim wak plee whum);
///                 trace_macros!(false);
///                 each_tt!(trom qlip winp xod);
///             
///             }
///             
/// --------------------------------------- log è°ƒè¯•å® -------------------------------------------------
///             
///             #![feature(log_syntax)]
///             
///             macro_rules! sing {
///                 () => {};
///                 ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);};
///             }
///             
///             fn main () {
///                 sing! {
///                     ^ < @ < . @ *
///                     '\x08' '{' '"' _ # ' '
///                     - @ '$' && / _ %
///                     ! ( '\t' @ | = >
///                     ; '\x08' '\'' + '$' ? '\x7f'
///                     , # '"' ~ | ) '\x07'
///                 }
///             }
///             
///             
/// --------------------------------------- tt æ’•å’¬æœº -------------------------------------------------
///             
///             macro_rules! mixed_rules {
///             
///                 // a æ¨¡å¼
///                 () => {};
///             
///                 // b æ¨¡å¼
///                 (trace $name:ident; $($tail:tt)*) => {
///                     {
///                         // $name åœ¨ println! ä¸­ï¼Œéœ€è¦è¢«æ•è·æˆ stringï¼Œå¦‚ï¼š println!(" = {:?}", $name) çœ‹ä¸‹å°±çŸ¥é“äº†
///                         println!(concat!(stringify!($name), " = {:?}"), $name);         
///                         mixed_rules!($($tail)*);
///                     }
///                 };
///             
///                 // c æ¨¡å¼
///                 (trace $name:ident = $init:expr; $($tail:tt)*) => {
///                     {
///                         let $name = $init;                                          
///                         println!(concat!(stringify!($name), " = {:?}"), $name);
///                         mixed_rules!($($tail)*);
///                     }
///                 };
///             }
///             
///             fn main() {
///                 let a = 42;                                 
///                 let b = "Ho-dee-oh-di-oh-di-oh!";                      
///                 let c = (false, 2, 'c');      
///                 mixed_rules!(
///                     trace a;                                                    // åŒ¹é… b æ¨¡å¼      a = 42                                    
///                     trace b;                                                    // åŒ¹é… b æ¨¡å¼      b = "Ho-dee-oh-di-oh-di-oh!"
///                     trace c;                                                    // åŒ¹é… b æ¨¡å¼      c = (false, 2, 'c')
///                     trace b = "They took her where they put the crazies.";      // åŒ¹é… c æ¨¡å¼      b = "They took her where they put the crazies."
///                     trace b;                                                    // åŒ¹é… b æ¨¡å¼      b = "They took her where they put the crazies."    è¿™é‡Œæ˜¯å› ä¸ºä¸Šé¢ä¸€æ¬¡ b è¢«èµ‹å€¼äº†
///                 );
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// ã€å£°æ˜å®çš„ç¼ºç‚¹ã€‘
/// 
///             1ã€ç¼ºå°‘å¯¹å®çš„è‡ªåŠ¨å®Œæˆå’Œå±•å¼€çš„æ”¯æŒ
///             
///             2ã€å£°æ˜å¼å®è°ƒå¼å›°éš¾
///             
///             3ã€ä¿®æ”¹èƒ½åŠ›æœ‰é™
///             
///             4ã€æ›´å¤§çš„äºŒè¿›åˆ¶
///             
///             5ã€æ›´é•¿çš„ç¼–è¯‘æ—¶é—´ (è¿™ä¸€æ¡å¯¹äºã€å£°æ˜å®ã€‘å’Œã€è¿‡ç¨‹å®ã€‘éƒ½å­˜åœ¨)
/// 
/// 
/// 
/// 
/// ######################################################################################################################################################
/// ######################################################################################################################################################
/// ######################################################################################################################################################
/// 
///                                                             è¿‡ç¨‹å® çš„ å®šä¹‰ åŠ ä½¿ç”¨
/// 
/// ###################################################################################################################################################### 
/// ######################################################################################################################################################
/// ######################################################################################################################################################
/// 
/// 
/// ä¸å£°æ˜å®ä¸åŒï¼Œè¿‡ç¨‹å®é‡‡ç”¨ Rust å‡½æ•°çš„å½¢å¼ï¼Œæ¥å—ä¸€ä¸ªï¼ˆæˆ–ä¸¤ä¸ªï¼‰æ ‡è®°æµ TokenStream å¹¶è¾“å‡ºä¸€ä¸ªæ ‡è®°æµ TokenStream
/// 
/// 
/// è¿‡ç¨‹å®çš„æ ¸å¿ƒï¼š
///         
///         åªæ˜¯ä¸€ä¸ªä» proc-macro crate type è¿™ç§ç±»å‹çš„åº“ä¸­æ‰€å¯¼å‡ºçš„å…¬æœ‰å‡½æ•°ï¼Œå› æ­¤å½“ç¼–å†™å¤šä¸ªè¿‡ç¨‹å®æ—¶ï¼Œä½ å¯ä»¥å°†å®ƒä»¬å…¨éƒ¨æ”¾åœ¨ä¸€ä¸ª crate ä¸­ã€‚
/// 
/// 
/// åœ¨ä½¿ç”¨ Cargo æ—¶ï¼Œå®šä¹‰ä¸€ä¸ª proc-macro crate çš„æ–¹å¼æ˜¯å°† Cargo.toml ä¸­çš„ lib.proc-macro é”®è®¾ç½®ä¸º trueï¼Œå°±åƒè¿™æ ·  (ä¾‹å¦‚ï¼š hello_procedural_macros çš„ Cargo.toml ä¸­æ·»åŠ )
///                     
///                     // Cargo.toml
///                     [lib]
///                     proc-macro = true
/// 
/// 
/// 
/// proc-macro ç±»å‹çš„ crate ä¼šéšå¼é“¾æ¥åˆ°ç¼–è¯‘å™¨æä¾›çš„ proc_macro åº“ï¼Œ proc_macro åº“åŒ…å«äº†å¼€å‘è¿‡ç¨‹å®æ‰€éœ€çš„æ‰€æœ‰å†…å®¹ï¼Œå¹¶ä¸”å®ƒå…¬å¼€äº†ä¸¤ä¸ªæœ€é‡è¦çš„ç±»å‹ï¼š
///             
///             1. TokenStream:     å®ƒè¡¨ç¤ºæˆ‘ä»¬æ‰€ç†ŸçŸ¥çš„æ ‡è®°æ ‘
///             2. Span:            å®ƒè¡¨ç¤ºæºä»£ç çš„ä¸€éƒ¨åˆ†ï¼Œä¸»è¦ç”¨äºé”™è¯¯ä¿¡æ¯çš„æŠ¥å‘Šå’Œå«ç”Ÿæ€§
/// 
/// 
///  
/// 
/// (è¿‡ç¨‹å®å…¶å®æ˜¯åœ¨ *tokenæµ(token streams)*ä¸Šæ“ä½œï¼Œè€Œä¸æ˜¯åœ¨æŸä¸ªæˆ–æŸäº› AST èŠ‚ç‚¹ä¸Šæ“ä½œã€‚tokenæµå¤§è‡´ç›¸å½“äº Vec<TokenTree>ï¼Œå…¶ä¸­ TokenTree å¯ä»¥å¤§è‡´è§†ä¸ºè¯æ³• tokenã€‚
/// ä¾‹å¦‚ï¼Œfoo æ˜¯æ ‡è¯†ç¬¦(Ident)ç±»å‹çš„ tokenï¼Œ. æ˜¯ä¸€ä¸ªæ ‡ç‚¹ç¬¦å·(Punct)ç±»å‹çš„ tokenï¼Œ1.2 æ˜¯ä¸€ä¸ªå­—é¢é‡(Literal)ç±»å‹çš„ tokenã€‚ä¸åŒäº Vec<TokenTree> çš„æ˜¯ TokenStream çš„å…‹éš†æˆæœ¬å¾ˆä½ã€‚
/// æ‰€æœ‰ç±»å‹çš„ token éƒ½æœ‰ä¸€ä¸ªä¸ä¹‹å…³è”çš„ Spanã€‚
/// Span æ˜¯ä¸€ä¸ªä¸é€æ˜çš„å€¼ï¼Œä¸èƒ½è¢«ä¿®æ”¹ï¼Œä½†å¯ä»¥è¢«åˆ¶é€ ã€‚Span è¡¨ç¤ºç¨‹åºå†…çš„æºä»£ç èŒƒå›´ï¼Œä¸»è¦ç”¨äºé”™è¯¯æŠ¥å‘Šã€‚å¯ä»¥äº‹å…ˆï¼ˆé€šè¿‡å‡½æ•° set_spanï¼‰é…ç½®ä»»ä½• token çš„ Spanã€‚)
/// 
/// 
/// 
/// è¿‡ç¨‹å®æ˜¯å­˜åœ¨äº crate ä¸­çš„å‡½æ•°ï¼Œæ‰€ä»¥å®ƒä»¬å¯ä»¥åƒ Rust é¡¹ç›®ä¸­çš„æ‰€æœ‰å…¶ä»–æ¡ç›®ä¸€æ ·ä½¿ç”¨
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///         1. ç±»å‡½æ•°  è¿‡ç¨‹å® (Function-like macros)
///         3. ç±»å±æ€§  è¿‡ç¨‹å® (Attribute-like macros)
///         2. æ´¾ç”Ÿ    è¿‡ç¨‹å® (Derive macros)
///         
/// 
/// 
/// 
/// 
/// 
/// ã€1.ã€ç±»å‡½æ•°ã€‘ è¿‡ç¨‹å®ã€‘
/// 
/// 
/// ç±»å‡½æ•°è¿‡ç¨‹å® æ˜¯ç”±ä¸€ä¸ªå¸¦æœ‰ proc_macroå±æ€§å’Œ (TokenStream) -> TokenStreamç­¾åçš„ å…¬æœ‰å¯è§æ€§å‡½æ•°å®šä¹‰
/// 
/// ç±»å‡½æ•°è¿‡ç¨‹å® åƒå£°æ˜å®é‚£æ ·è¢«è°ƒç”¨ï¼Œå³ makro!(â€¦) è¿™æ ·è°ƒç”¨ï¼›å®ƒä¹Ÿæ˜¯å”¯ä¸€ä¸€ä¸ªåœ¨å•ç‹¬çœ‹è°ƒç”¨å½¢å¼æ—¶ï¼Œæ— æ³•ä¸å£°æ˜å®åŒºåˆ†å¼€çš„å®
/// 
/// 
/// 
/// (ä¸å£°æ˜æ€§å®ä¸åŒï¼Œç±»å‡½æ•°è¿‡ç¨‹å® å¯¹å…¶è¾“å…¥æ²¡æœ‰ç‰¹å®šçš„é™åˆ¶
/// 
/// å³ä¸æ”¯æŒ ç±»å‹å‚æ•°ï¼Œå› ä¸º ã€è¿‡ç¨‹å® ç›´æ¥ä½œç”¨äºæ ‡è®°ã€‘ï¼Œè€Œä¸æ˜¯æ ¹æ®ç‰‡æ®µåˆ†ç±»ç¬¦ ç±»å‹å‚æ•°æˆ–ç±»ä¼¼çš„ä¸œè¥¿ï¼ˆæ¯”å¦‚åå¤ï¼‰åŒ¹é…å®ƒä»¬
/// 
//  è¿‡ç¨‹å®æ›´å¼ºå¤§ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥ä»»æ„ä¿®æ”¹å…¶è¾“å…¥ï¼Œå¹¶ç”Ÿæˆä»»ä½•æ‰€éœ€çš„è¾“å‡ºï¼Œåªè¦è¾“å‡ºåœ¨ Rust çš„è¯­æ³•èŒƒå›´å†…)
/// 
/// 
/// ç±»å‡½æ•°è¿‡ç¨‹å® å¯ä»¥åœ¨ä»»ä½•å®è°ƒç”¨ä½ç½®è°ƒç”¨ï¼š
///         
///         è¿™äº›ä½ç½®åŒ…æ‹¬è¯­å¥ã€è¡¨è¾¾å¼ã€æ¨¡å¼ã€ç±»å‹è¡¨è¾¾å¼ã€ç¨‹åºé¡¹å¯ä»¥å‡ºç°çš„ä½ç½® (åŒ…æ‹¬externå—é‡Œã€å›ºæœ‰(inherent)å®ç°é‡Œå’Œ traitå®ç°é‡Œã€ä»¥åŠ traitå£°æ˜é‡Œ)
/// 
/// 
/// 
/// 
/// 
/// 
/// å¦‚, åœ¨ hello_procedural_macros çš„ Cargo.toml ä¸­æ·»åŠ :  
/// 
///             [lib]
///             proc-macro = true
/// 
/// ç„¶ååœ¨ hello_procedural_macros ä¸­å®šä¹‰:  
/// 
/// 
/// 
///             // å®šä¹‰ ã€ç±»å‡½æ•°ã€‘ è¿‡ç¨‹å®
///             #![crate_type = "proc-macro"]
///             extern crate proc_macro;
///             use proc_macro::TokenStream;
///             
///             #[proc_macro]
///             pub fn make_answer(_item: TokenStream) -> TokenStream {
///                 "fn answer() -> u32 { 42 }".parse().unwrap()
///             }
/// 
/// æœ€ååœ¨é¡¹ç›®ä¸­ä½¿ç”¨:
/// 
/// 
/// 
/// 
/// 
/// 
///             // ä½¿ç”¨ hello_procedural_macros ä¸­å®šä¹‰çš„ ã€ç±»å‡½æ•°ã€‘ è¿‡ç¨‹å®
///             extern crate hello_procedural_macros;
///             use hello_procedural_macros::make_answer;
///             
///             
///             // è°ƒç”¨ å®
///             make_answer!(Gavin);                        // è¾“å‡º Gavin, å¹¶å£°æ˜äº† fn answer å‡½æ•°
/// 
///             // æ³¨æ„: ä¹Ÿå¯ä»¥ä¸è¾“å…¥ä»»ä½•ç›´æ¥è°ƒç”¨, åƒè¿™æ ·  make_answer!();  // åªå£°æ˜äº† fn answer å‡½æ•°
/// 
///             fn main() {
///                 // ä½¿ç”¨ å®è¢«è°ƒç”¨åç»“æœç”Ÿæˆçš„ å‡½æ•°
///                 println!("{}", answer());               // è¾“å‡º 42 
///             }
///             
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// ã€2.ã€ç±»å±æ€§ã€‘ è¿‡ç¨‹å®ã€‘
/// 
/// 
/// 
/// 
/// 
/// ç±»å±æ€§è¿‡ç¨‹å® å®šä¹‰å¯ä»¥é™„åŠ åˆ°ç¨‹åºé¡¹ä¸Šçš„æ–°çš„å¤–éƒ¨å±æ€§ï¼Œè¿™äº›ç¨‹åºé¡¹åŒ…æ‹¬å¤–éƒ¨(extern)å—ã€å›ºæœ‰å®ç°ã€trateå®ç°ï¼Œä»¥åŠ traitå£°æ˜ä¸­çš„å„ç±»ç¨‹åºé¡¹
/// 
/// ç±»å±æ€§è¿‡ç¨‹å® å®šä¹‰äº†å¯æ·»åŠ åˆ°æ¡ç›®çš„çš„æ–°å¤–éƒ¨å±æ€§ã€‚è¿™ç§å®é€šè¿‡ #[attr] æˆ– #[attr(â€¦)] æ–¹å¼è°ƒç”¨
/// 
/// 
/// ç±»å±æ€§è¿‡ç¨‹å® æœ‰ä¸¤ä¸ªè¾“å…¥å‚æ•°ï¼š
///             
///             ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ å±æ€§åç§°åé¢çš„å¸¦åˆ†éš”ç¬¦çš„æ ‡è®°æ ‘ï¼Œä¸åŒ…æ‹¬å®ƒå‘¨å›´çš„åˆ†éš”ç¬¦ã€‚   å¦‚æœåªæœ‰å±æ€§åç§°ï¼ˆå…¶åä¸å¸¦æ ‡è®°æ ‘ï¼Œæ¯”å¦‚ #[attr]ï¼‰ï¼Œåˆ™è¿™ä¸ªå‚æ•°çš„å€¼ä¸ºç©º
/// 
///             ç¬¬äºŒä¸ªå‚æ•°æ˜¯ æ·»åŠ äº†è¯¥è¿‡ç¨‹å®å±æ€§çš„æ¡ç›®ï¼Œä½†ä¸åŒ…æ‹¬è¯¥è¿‡ç¨‹å®æ‰€å®šä¹‰çš„å±æ€§ã€‚ å› ä¸ºè¿™æ˜¯ä¸€ä¸ª active å±æ€§ï¼Œåœ¨ä¼ é€’ç»™è¿‡ç¨‹å®ä¹‹å‰ï¼Œè¯¥å±æ€§å°†ä»æ¡ç›®ä¸­å‰¥ç¦»å‡ºæ¥
/// 
/// 
/// 
/// 
/// 
/// å¦‚, åœ¨ hello_procedural_macros çš„ Cargo.toml ä¸­æ·»åŠ :  
/// 
///             [lib]
///             proc-macro = true
/// 
/// ç„¶ååœ¨ hello_procedural_macros ä¸­å®šä¹‰:  
/// 
/// 
/// 
///             // å®šä¹‰ ã€ç±»å±æ€§ã€‘ è¿‡ç¨‹å®
///             #![crate_type = "proc-macro"]
///             extern crate proc_macro;
///             use proc_macro::TokenStream;
/// 
///             #[proc_macro_attribute]
///             pub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {
///                 println!("attr: \"{}\"", attr.to_string());
///                 println!("item: \"{}\"", item.to_string());
///                 item
///             }
/// 
/// 
/// æœ€ååœ¨é¡¹ç›®ä¸­ä½¿ç”¨:
/// 
/// 
/// 
/// 
/// 
/// 
///             // ä½¿ç”¨ hello_procedural_macros ä¸­å®šä¹‰çš„ ã€ç±»å±æ€§ã€‘ è¿‡ç¨‹å®
///             extern crate hello_procedural_macros;
///             use hello_procedural_macros::show_streams;
///             
///             // ç¤ºä¾‹: åŸºç¡€å‡½æ•°
///             #[show_streams]
///             fn invoke1() {}
///             
///             // ç¤ºä¾‹: å¸¦è¾“å…¥å‚æ•°çš„å±æ€§
///             #[show_streams(bar)]
///             fn invoke2() {}
///             
///             
///             // ç¤ºä¾‹: è¾“å…¥å‚æ•°ä¸­æœ‰å¤šä¸ª token çš„
///             #[show_streams(multiple => tokens)]
///             fn invoke3() {}
///             
///             
///             // ç¤ºä¾‹:
///             #[show_streams { delimiters }]
///             fn invoke4() {}
///             
///             
///             fn main() {
///             
///                 //  attr: ""
///                 //  item: "fn invoke1() {}"
///                 invoke1();
///             
///                 //  attr: "bar"
///                 //  item: "fn invoke2() {}"
///                 invoke2();
///             
///                 //  attr: "multiple => tokens"
///                 //  item: "fn invoke3() {}"
///                 invoke3();
///             
///                 //  attr: "delimiters"
///                 //  item: "fn invoke4() {}"
///                 invoke4();
///             
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// ã€3.ã€æ´¾ç”Ÿã€‘ è¿‡ç¨‹å®ã€‘
/// 
/// 
/// 
/// æ´¾ç”Ÿè¿‡ç¨‹å® ä¸ºæ´¾ç”Ÿ(derive)å±æ€§å®šä¹‰æ–°è¾“å…¥ã€‚
/// 
///     è¿™ç±»å®åœ¨ç»™å®šè¾“å…¥ç»“æ„ä½“(struct)ã€æšä¸¾(enum)æˆ–è”åˆä½“(union) tokenæµçš„æƒ…å†µä¸‹åˆ›å»ºæ–°ç¨‹åºé¡¹ã€‚    (deriveè¿‡ç¨‹å®åªèƒ½ç”¨åœ¨ struct å’Œ enum  å’Œ  unionä¸Š)
/// 
///     å®ƒä»¬ä¹Ÿå¯ä»¥å®šä¹‰æ´¾ç”Ÿå®è¾…åŠ©å±æ€§ã€‚
///     (è¾…åŠ©å±æ€§çš„å®šä¹‰æ–¹å¼æ˜¯å‘ proc_macro_derive å±æ€§å¢åŠ  attributes(helper0, helper1, ..) å‚æ•°ï¼Œè¯¥å‚æ•°å¯åŒ…å«ç”¨é€—å·)
/// 
/// 
/// 
/// è‡ªå®šä¹‰æ´¾ç”Ÿå®ç”±å¸¦æœ‰ proc_macro_deriveå±æ€§å’Œ (TokenStream) -> TokenStreamç­¾åçš„å…¬æœ‰å¯è§æ€§å‡½æ•°å®šä¹‰
/// 
/// 
/// 
/// 
/// 
/// 
/// å¦‚, åœ¨ hello_procedural_macros çš„ Cargo.toml ä¸­æ·»åŠ :  
/// 
///             [lib]
///             proc-macro = true
/// 
/// ç„¶ååœ¨ hello_procedural_macros ä¸­å®šä¹‰:  
/// 
/// 
/// 
/// 
/// 
///             // å®šä¹‰  ã€æ´¾ç”Ÿã€‘ è¿‡ç¨‹å®
///             use quote::quote;
///             use syn;
///             use syn::DeriveInput;
///             
///             #[proc_macro_derive(HelloMacro)]
///             pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
///                 
///                 // åŸºäº input æ„å»º AST è¯­æ³•æ ‘
///                 let ast:DeriveInput = syn::parse(input).unwrap();
///             
///                 // æ„å»ºç‰¹å¾å®ç°ä»£ç 
///                 impl_hello_macro(&ast)
///             }
///             
///             fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
///                 
///                 // å°† struct åç§°èµ‹å€¼ç»™ name å˜é‡
///                 let name = &ast.ident;
///                 
///                 // å¯ä»¥å®šä¹‰æˆ‘ä»¬æƒ³è¦è¿”å›çš„ Rust ä»£ç 
///                 let gen = quote! {
///             
///                     // #name æ˜¯ quote lib çš„è¯­æ³•
///                     //
///                     // æ­¤å¤„ä¸ºä½¿ç”¨ äº† #[derive(HelloMacro)] çš„ struct å°†è¢«å®ç° trait HelloTrait çš„ fn hello_macro å‡½æ•°
///                     //
///                     // å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ trait HelloTrait å¿…é¡»åœ¨å½“å‰ æ´¾ç”Ÿè¿‡ç¨‹å® HelloMacro ä½¿ç”¨çš„ scope å†…èƒ½æ‰¾åˆ°å®šä¹‰
///                     impl HelloTrait for #name {
///             
///                         fn hello_macro() {
///                             println!("Hello, Macro! My name is {:?}!", stringify!(#name));
///                         }
///                     }
///                 };
///             
///                 // ç”±äºç¼–è¯‘å™¨éœ€è¦çš„å†…å®¹å’Œ quote! ç›´æ¥è¿”å›çš„ä¸ä¸€æ ·ï¼Œå› æ­¤è¿˜éœ€è¦ä½¿ç”¨ .into æ–¹æ³•å…¶è½¬æ¢ä¸º TokenStream
///                 gen.into()
///             
///                 // ä¸Šè¿°å¯ä»¥è¿™æ ·ï¼š
///                 //
///                 //      let ret = gen.into();  // å¾—åˆ°ç±»å‹ä¸º TokenStream
///                 //      
///                 //      ret
///                 // æŸ¥çœ‹è¿”å›ä¿¡æ¯
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// æœ€ååœ¨é¡¹ç›®ä¸­ä½¿ç”¨:
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///             // ä½¿ç”¨ hello_procedural_macros ä¸­å®šä¹‰çš„ ã€æ´¾ç”Ÿã€‘ è¿‡ç¨‹å®
///             extern crate hello_procedural_macros;
///             use hello_procedural_macros::HelloMacro;
///             
///             #[derive(HelloMacro)]
///             struct SomeData (u32, String);
///             
///             
///             #[derive(HelloMacro)]
///             struct SomeData2 {
///                 name: String
///             }
///             
///             // å› ä¸º æ´¾ç”Ÿè¿‡ç¨‹å® HelloMacro ä¸­ä½¿ç”¨äº† trait HelloTrait
///             // æ‰€ä»¥ æ´¾ç”Ÿè¿‡ç¨‹å® HelloMacro è¢«ä½¿ç”¨çš„ scope å†…å¿…é¡»èƒ½æ‰¾åˆ° trait HelloTrait çš„å®šä¹‰
///             trait HelloTrait  {
///                 fn hello_macro();
///             }
///             
///             fn main() {
///                
///                 SomeData::hello_macro();        // Hello, Macro! My name is SomeData!
///                 SomeData2::hello_macro();       // Hello, Macro! My name is SomeData2!
///             
///             }
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// --------------------------------------- é«˜çº§çš„ ã€derive è¿‡ç¨‹å®ã€‘ å®šä¹‰ -------------------------------------------------
/// 
/// 
/// 
/// å¦‚, åœ¨ hello_procedural_macros çš„ Cargo.toml ä¸­æ·»åŠ :  
/// 
///             [lib]
///             proc-macro = true
/// 
/// ç„¶ååœ¨ hello_procedural_macros ä¸­å®šä¹‰:  
/// 
/// 
/// 
/// 
/// 
///             // å®šä¹‰  ã€æ´¾ç”Ÿã€‘ è¿‡ç¨‹å®
///             use quote::quote;
///             use syn::{self, Data};
///             use syn::DeriveInput;
/// 
/// 
/// 
///             #[proc_macro_derive(MyDefaultMacro)]
///             pub fn my_default(input: TokenStream) -> TokenStream {
///             
///                 let ast: DeriveInput = syn::parse(input).unwrap();
///             
///                 // å°† struct åç§°èµ‹å€¼ç»™ id å˜é‡
///                 let id = ast.ident;
///                 //id = Ident { ident: "SomeData", span: #0 bytes(248..256) }
///                 //id = Ident { ident: "User", span: #0 bytes(305..309) }
///                 // println!("id = {:?}", id);
///             
///                 // let name = &ast.ident;
///                 // //name = Ident { ident: "SomeData", span: #0 bytes(248..256) }
///                 // //name = Ident { ident: "User", span: #0 bytes(305..309) }
///                 // println!("name = {:?}", name);
///             
///             
///                 // ä»è§£æå‡ºæ¥çš„ ast ä¸Šè¯»å–å‡º struct çš„ä¿¡æ¯
///                 let Data::Struct(s) = ast.data else {
///                     panic!("MyDefault derive macro must use in struct");
///                 };
///             
///             
///                 // å£°æ˜ä¸€ä¸ªæ–°çš„ astï¼Œç”¨äºåŠ¨æ€æ„å»ºå­—æ®µèµ‹å€¼çš„ token
///                 let mut field_ast = quote!();
///             
///                 // è¿™é‡Œå°±æ˜¯è¦åŠ¨æ€æ·»åŠ  token çš„åœ°æ–¹äº†ï¼Œéœ€è¦åŠ¨æ€å®Œæˆ Self çš„å­—æ®µèµ‹å€¼
///                 //
///                 // é€ä¸ªéå† struct ä¸Šçš„ field
///                 for (idx,f) in s.fields.iter().enumerate() {
///             
///             
///                    
///             
///                     let (field_name, field_ty) = (&f.ident, &f.ty);
///                     
///                     // println!("field_name = {:?}", field_name);
///             
///                     if field_name.is_none(){
///                         
///                          // æ²¡æœ‰ ident è¡¨ç¤ºæ˜¯åŒ¿åå­—æ®µï¼Œå¯¹äºåŒ¿åå­—æ®µï¼Œéƒ½éœ€è¦æ·»åŠ  `#_field_idx: #field_type::default(),` è¿™æ ·çš„ä»£ç 
///                          //
///                          // åƒ struct SomeData (u32,String); è¿™æ ·çš„ field ä¿¡æ¯å°±æ˜¯ None
///                         let _field_idx  = syn::Index::from(idx);
///                         field_ast.extend(quote! {
///                             #_field_idx: #field_ty::default(),
///                         });
///                     }else{
///                         
///                         // å¯¹äºå‘½åå­—æ®µï¼Œéƒ½éœ€è¦æ·»åŠ  `#field_name: #field_type::default(),` è¿™æ ·çš„ä»£ç 
///                         //
///                         // åƒ
///                         //
///                         //  struct User {
///                         //      name: String,
///                         //      data: SomeData,
///                         //  }
///                         field_ast.extend(quote! {
///                             #field_name: #field_ty::default(),
///                         });
///                     }
///                 }
///                 
///                 quote! {
///                     impl MyDefaultTrait for # id {
///                         fn default() -> Self {
///                             
///                             // è¿”å›è‡ªèº«
///                             Self {
///                                 #field_ast
///                             }
///                         }
///                     }
///                 }.into()
///                 
///             }
/// 
/// 
/// 
/// 
/// æœ€ååœ¨é¡¹ç›®ä¸­ä½¿ç”¨:
/// 
/// 
/// 
/// 
/// 
/// 
/// 
///             // ä½¿ç”¨ hello_procedural_macros ä¸­å®šä¹‰çš„ ã€æ´¾ç”Ÿã€‘ è¿‡ç¨‹å®
///             extern crate hello_procedural_macros;
///             use hello_procedural_macros::MyDefaultMacro;
///             
///             #[derive(MyDefaultMacro)]
///             struct SomeData (u32,String);
///             
///             #[derive(MyDefaultMacro)]
///             struct User {
///                 name: String,
///                 data: SomeData,
///             }
///             
///             
///             // å› ä¸º æ´¾ç”Ÿè¿‡ç¨‹å® HelloMacro ä¸­ä½¿ç”¨äº† trait HelloTrait
///             // æ‰€ä»¥ æ´¾ç”Ÿè¿‡ç¨‹å® HelloMacro è¢«ä½¿ç”¨çš„ scope å†…å¿…é¡»èƒ½æ‰¾åˆ° trait HelloTrait çš„å®šä¹‰
///             trait MyDefaultTrait  {
///                 fn default() -> Self;
///             }
///             
///             fn main() {
///                
///                 SomeData::default();       
///                 User::default();       
///             
///                 // åœ¨é¡¹ç›®æ ¹ç›®å½•ä½¿ç”¨: cargo expand --bin hello_cargo_rusts å±•å¼€ MyDefaultMacro å®ï¼Œå¾—åˆ°ï¼š
///                 //
///                 //
///                 //      #![feature(prelude_import)]
///                 //      #[prelude_import]
///                 //      use std::prelude::rust_2021::*;
///                 //      #[macro_use]
///                 //      extern crate std;
///                 //      extern crate hello_procedural_macros;
///                 //      use hello_procedural_macros::MyDefaultMacro;
///                 //      struct SomeData(u32, String);
///                 //      impl MyDefaultTrait for SomeData {
///                 //          fn default() -> Self {
///                 //              Self {
///                 //                  0: u32::default(),
///                 //                  1: String::default(),
///                 //              }
///                 //          }
///                 //      }
///                 //      struct User {
///                 //          name: String,
///                 //          data: SomeData,
///                 //      }
///                 //      impl MyDefaultTrait for User {
///                 //          fn default() -> Self {
///                 //              Self {
///                 //                  name: String::default(),
///                 //                  data: SomeData::default(),
///                 //              }
///                 //          }
///                 //      }
///                 //      trait MyDefaultTrait {
///                 //          fn default() -> Self;
///                 //      }
///                 //      fn main() {
///                 //          SomeData::default();
///                 //          User::default();
///                 //      }
///             
///             }
/// 
/// 
/// 
///
/// 
/// ######################################################################################################################################################
/// 宏  的 定义 及 使用
/// ###################################################################################################################################################### 
/// 
/// 1、 声明宏：   编写类似于 match 表达式
/// 2、 过程宏：   对它所给的 Rust 代码的抽象语法树（AST）进行操作， 如: #[derive(Debug)]
/// 
/// 
/// 
/// 
/// ######################################################################################################################################################
/// 声明宏 的 定义 及 使用
/// ###################################################################################################################################################### 
/// 
/// 
/// 
/// 
/// 
/// 宏定义的内容由 规则(rule) 组成, 每一条规则都形如:
///
///  (Pattern) => { Exapnsion };
/// 
/// 其中所使用的的 括号  (), [], {} 是不受限制的, 调用时不会对括号进行检查.
/// 
/// () => {} 看起来很神秘, 因为它不是标准的 rust 语法, 是 macro_rules! 这个宏自己发明的, 用来表示一条宏规则:=> 左边是【匹配模式】, 右边是【等待展开的代码】
/// 
/// 类似于Rust中的match语句, 在macro_rules!中可以定义多条宏规则,  当宏被调用时, 会由上而下对每个规则进行匹配, 如果某一条规则与输入 完全 匹配, 则立刻进行该规则所对应的展开.
/// 
///
/// 
/// macro_rules! hey{
///     () => {}, 
///     () => {}
/// }
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 又如:
/// 
/// 
/// macro_rules! add{
///     // first arm match add!(1, 2),  add!(2, 3) etc
///        ($a:expr, $b:expr)=>{
///            {
///                $a+$b
///            }
///        };
///    // Second arm macth add!(1),  add!(2) etc
///        ($a:expr)=>{
///            {
///                $a
///            }
///        }
///    }
///    
///    fn main(){
/// 
///        let x=0;
/// 
///        add!(1, 2);   // 匹配到 宏中 第一个规则
///        add!(x);     // 匹配到 宏中 第二个规则
///    }
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 宏的参数描述为:  
/// 
///         **************************
///         *   $参数名称: 参数类型   *
///         **************************
/// 
/// 如:         $a:expr
/// 
/// 参数类型叫做: 选择器、token类型
/// 
/// 
/// 
/// 
/// 参数类型:
/// 
/// 
/// 
///         1、 item: Item, 如函数定义, 常量声明, 结构体, 模块 等
///         2、 block: BlockExpression, 一个语句块或一个表达式, 由花括号所包围, 如: { ... }
///         3、 stmt: Statement, 语句, 如: let 表达式 (传入为 stmt 类型的参数时 【不需要末尾的分号】, 但需要分号的 item 语句除外)
///         4、 pat: Pattern, 模式匹配中的 【模式】, 如: Some(a)
///         5、 expr: Expression, 表达式, 如: Vec::new()
///         6、 ty: Type, 类型, 如: i32
///         7、 ident: IDENTIFIER_OR_KEYWORD, 【标识符】 或 【关键字】, 如: i 或 self
///         8、 path: TypePath, 类型路径, 如: std::result::Result
///         9、 tt: TokenTree, Token 树, 被匹配的定界符 (、[] 或 {} 中的单个或多个 token
///         10、 meta: Attr, 形如: #[...] 和 #![...] 的属性中的内容
///         11、 lifetime: LIFETIME_TOKEN, 生命周期 Token, 如: 'static
///         12、 vis: Visibility, 可能为空的 【可见性限定符】, 如: pub
///         13、 literal: 匹配 ? LiteralExpression
/// 
///     【其中, tt 类型可以被视为 Rust 宏的 Any】
/// 
/// 
/// 宏还对 各种类型的参数  捕获之后  所允许的内容  添加了限制, 以避免语义冲突:
/// 
/// 
/// 
///         1、 item: 任何标记
///         2、 block: 任何标记
///         3、 stmt: =>、;、,
///         4、 pat: =>、,、=、|、if 或 in
///         5、 expr: =>、;、,
///         6、 ty: {、[、=>、,、>、=、:、;、|、as 或 where
///         7、 ident: 任何标记
///         8、 path: {、[、=>、,、>、=、:、;、|、as 或 where
///         9、 meta: 任何标记
///         10、 tt: 任何标记
/// 
/// 
/// 
/// 重复模式:
/// 
/// 
///         *******************************************************
///         *  $( 需要重复的内容 ) [可选的]分隔符  [必选的]重复标志   *
///         *******************************************************
/// 
/// 可选的分隔符:  常见的有 , 和 ;
/// 必选的重复标记:  三种     * (零次或多次)       + (一次或多次)        ? (零次或一次))
/// 
/// 如:
///         $( $i:expr ),
///         $( $i:expr, )*
///         $( $i:expr ),* $(,)?
/// 
/// 
/// 如下:
/// 
/// 
///          入零个或多个相同类型的值, 构造一个包含这些值（按照顺序）的 Vec.
///        
///          macro_rules! build_vec {
///              (
///                  $( $i:expr ),*                          // 重复, 以支持任意数量的参数
///                  $(,)?                                   // 可选的末尾逗号
///              ) => {
///                  {                                       // 创建一个块, 以支持多条语句
///                      let mut vec = Vec::new();           // 构造一个 Vec, 必须为 mut, 否则下文无法进行 push
///          
///                      $(                                  // 重复, 将每个 $i 推入 vec 中
///                          vec.push($i);
///                      )*
///          
///                      vec                                 // 返回 vec
///                  }
///              }
///          }
///        
/// ----------------------------------------------------------------------------------------------
/// 
/// 又如:
/// 
/// 
///          macro_rules! add{
///  
///              // 单参数情况下
///                 ($a:expr)=>{
///                     $a
///                 };
///  
///             // 在传递两个参数的情况下
///                 ($a:expr,$b:expr)=>{
///                     {
///                         $a+$b
///                     }
///                 };
///  
///             // 使用其他参数再次调用 add 宏
///                 ($a:expr,$($b:tt)*)=>{
///                    {
///                        $a+add!($($b)*)
///                    }
///                 }
///             }
///             
///             fn main(){
///               println!("{}",add!(1,2,3,4));
///             }
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 又如:
/// 
/// 
/// 
/// 
///             macro_rules! make_public{
///                 (
///                  $(#[$meta:meta])*
///                  $vis:vis struct $struct_name:ident {
///                     $(
///                     $(#[$field_meta:meta])*
///                     $field_vis:vis $field_name:ident : $field_type:ty
///                     ),*$(,)+
///                 }
///                 ) => {
///             
///                         $(#[$meta])*
///                         pub struct $struct_name{
///                             $(
///                             $(#[$field_meta:meta])*
///                             pub $field_name : $field_type,
///                             )*
///                         }
///                 }
///             }
///             
///             fn main(){
///                 make_public!{
///                     #[derive(Debug)]
///                     struct Name{
///                         n:i64,
///                         t:i64,
///                         g:i64,
///                     }
///                 }
///             
///                 // 得到：
///                 // #[derive(Debug)]
///                 // pub struct name {
///                 //     pub n: i64,
///                 //     pub t: i64,
///                 //     pub g: i64,
///                 // }
///             }
///             
///             
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 声明宏的缺点：
/// 
///             1、缺少对宏的自动完成和展开的支持
///             
///             2、声明式宏调式困难
///             
///             3、修改能力有限
///             
///             4、更大的二进制
///             
///             5、更长的编译时间 (这一条对于【声明宏】和【过程宏】都存在)
/// 
/// 
/// 
/// 
/// 
/// 
/// ######################################################################################################################################################
/// 过程宏 的 定义 及 使用
/// ###################################################################################################################################################### 
/// 
/// 
/// 过程宏接收一个 TokenStream 作为参数并返回另一个 TokenStream
/// 
/// 
/// 
///         1、类属性  宏（Attribute-like macros）
///         2、派生    宏（Derive macros）
///         3、类函数  宏（Function-like macros）
/// 
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 1、类属性  宏
/// 
/// ----------------------------------------------------------------------------------------------
/// 
/// 
/// 类属性宏使你能够创建一个自定义的属性，将其附加到一个项目上，并允许对该项目进行操作.  它也可以接受参数.  
/// 
/// #[some_attribute_macro(some_argument)]    // some_attribute_macros 是一个类属性宏.  它操纵着函数 perform_task
/// fn perform_task(){
///     / some code
/// }
/// 
/// 
/// 
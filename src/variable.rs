/// 
/// let 【绑定】 变量  (move 语言的是 【创建变量】)
/// 
/// lat a = 5;
/// 
/// 【不可变  变量】
/// 
/// let x = 6;
/// 
/// 
/// 【可变  变量】
/// 
/// let mut x = 7;
/// 
/// 
/// 【不可变  引用】
/// 
/// let x = 6;    ---------------------------------------------------------         x -> 6
/// 
/// let y = &x;    (y 的类型为 x 的   不可变引用) ---------------------------         y -> x -> 6
/// 
/// 【可变  引用】
/// 
/// let mut x = 6;    (必须先是  可变变量， 后面才可以创建  可变引用)                  x -> 6  (可被改变)           即可以变成： x -> 8
/// 
/// let y = &mut x;   (y 的类型为 x 的   可变引用)                                   y -> x -> 6   (可被改变)     即可以变成： y -> x -> 8
/// 
/// [变量的  可变引用， 只能有一个; 类似 【读写 mutex】]
/// 
/// 
/// ****************************************************************************************************************************************
/// 【获取 变量的 引用，称之为 借用】    因为同一时刻只会有一个 引用
/// ****************************************************************************************************************************************
/// 




/// ****************************************************************************************************************************************
/// 【变量解构】
/// ****************************************************************************************************************************************
///
/// 
/// let (a, mut b): (bool, bool) = (true, false);           ---------------------      a = true, 不可变; b = false, 可变
/// 
/// 
/// 
/// ****************************************************************************************************************************************
/// 【解构式     赋值】
/// ****************************************************************************************************************************************
/// 
/// 
/// /////////////////////////////////////////////////////////////////////////////////// 
/// ///////////////////////////////////////////////////////////////////////////////////
///                                                                             ///////
/// 三种方式去 (接收) 解构：      ----------------          元组、切片和结构体  ///////
///                                                                             ///////
/// ///////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////
/// 
/// 
/// 这种使用方式跟之前的 let 保持了一致性，但是 let 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值
/// 
/// 
/// 
/// 1. 元组
/// 
/// (a, b) = (1, 2);      ------------   solidity 类似这种
/// 
/// 2. 切片
/// 
/// [c, .., d, _] = [1, 2, 3, 4, 5];
/// 
/// 3. 结构体
/// 
/// Struct { e, .. } = Struct { e: 5 };      --------------    move 类似这种
/// 
/// 


/// ****************************************************************************************************************************************
/// 【整数】                    默认使用 i32
/// ****************************************************************************************************************************************
/// 
/// 
///
/// |   长度    |   有符号    |    无符号    |
/// | --------  | ---------- | -----------  |
/// |   8 bit   |     i8     |      u8      |
/// |   16 bit  |     i8     |      u8      |
/// |   32 bit  |     i8     |      u8      |
/// |   64 bit  |     i8     |      u8      |
/// |  128 bit  |     i8     |      u8      |
/// |  依赖底层  |   isize   |     usize     |
/// 
/// 
/// 
/// 
/// -----------------------------------------------------
/// 字面量                                  isize 和 usize 的主要应用场景是用作集合的索引
/// -----------------------------------------------------
/// 
/// |    字面量     |     示例     |
/// | -----------   | ----------—- |
/// |字节 (仅限u8)  |     b'A'     |                    ---------------   字母'A'的 ASCII 编码是 65
/// |      二       |  0b11110000  |                    ---------------   240
/// |      八       |      0o77    |                    ---------------   63   
/// |      十       |     98_222   |                    ---------------   98222
/// |    十六       |      0xff    |                    ---------------   255
/// 
/// 


/// ****************************************************************************************************************************************
/// 【浮点】                     默认浮点类型是 f64
/// ****************************************************************************************************************************************
/// 
/// 



/// ****************************************************************************************************************************************
/// 【序列】
/// ****************************************************************************************************************************************
/// 
/// 
/// 1..5   =>  [1, 2, 3, 4]
/// 
/// 
/// 1..=5  => [1, 2, 3, 4, 5]
/// 
/// 
/// 'a'..='z'  => [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z]
 


 /// 类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
 /// 
 /// Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()




 





/// ****************************************************************************************************************************************
/// 字符 char、  bool、 unit 类型
/// ****************************************************************************************************************************************
/// 
/// () 即是 unit 类型 【唯一】的值
/// 
/// 可以用 () 作为 map 的值，表示我们不关注具体的值，只关注 key。 这种用法和 Go 语言的 struct{} 类似，可以作为一个值用来占位，但是完全不占用任何内存
/// 
/// 





/// ****************************************************************************************************************************************
/// 【 &str 和  String】                    字符串字面值 (&str) 是 【不可变】 的，因为被硬编码到程序代码中
/// ****************************************************************************************************************************************
/// 
/// 
/// 
/// 
/// **************************
/// 1. &str
/// **************************
/// 
/// 
/// let s ="hello"，s 是被硬编码进程序里的字符串值 (类型为 &str)
/// 
/// 
/// 并非所有 字符串的值都能在 编写代码时得知
/// 
/// 
/// 
/// 
/// 
/// **************************
/// 2. String
/// **************************
/// 
/// 
/// 动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本
/// 
/// let s = String::from("hello");
/// 
/// 或者
/// 
/// let mut s = String::from("hello");     ----------------> 直接可以将  String 用 mut String 来接收 ???
/// 
/// 
/// 
/// 
/// 
/// **************************
/// 字符串【切片】  &str
/// **************************
/// 
/// 
/// let s = String::from("hello");
/// 
/// let slice = &s[0..2];           --------------  &str 类型
/// let slice = &s[..2];            --------------  &str 类型
/// 
/// 
/// 
/// 
/// **************************
/// &str 和 String 的转换
/// **************************
/// 
/// ---------------------
/// 1. &str  ->  String 
/// ---------------------
/// 
/// String::from("hello,world")
/// 
/// 或
/// 
/// "hello,world".to_string()
/// 
/// ---------------------
/// 2. String  ->  &str
/// ---------------------
/// 
/// let s = String::from("hello,world!");
/// 
/// let x = &s; ------------> 这个不是  &String 么???   在 slice.rs 中有个别例子  fn first_word(s: &str) -> &str  可以用 &String 传进去，说明 &String 可以隐式转换成 &str
/// 
/// 或者
/// 
/// let y = &s[..];
/// 
/// 或者
/// 
/// let z = s.as_str();
/// 

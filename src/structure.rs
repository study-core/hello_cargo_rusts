/// 
/// ********************************************************************
/// 
/// user1 的任何字段都不可以更改
/// 
/// ********************************************************************
/// 
/// fn main() {
///     let user1 = User {
///         active: true,
///         username: String::from("someusername123"),
///         email: String::from("someone@example.com"),
///         sign_in_count: 1,
///     };
/// }
/// 
/// 
/// ********************************************************************
/// 
/// user1 可以修改自身的 字段
/// 
/// ********************************************************************
/// 
/// 
/// fn main() {
///     let mut user1 = User {
///         active: true,
///         username: String::from("someusername123"),
///         email: String::from("someone@example.com"),
///         sign_in_count: 1,
///     };
/// 
///     user1.email = String::from("anotheremail@example.com");
/// }
///
/// 
/// 
/// 
/// ********************************************************************
/// 
/// user2 剩余的字段使用 user1 的
/// 
/// ********************************************************************
/// 
/// 
/// 
/// 
/// fn main() {
///     // --snip--
/// 
///     let user2 = User {   //  user1 的所有权已经被转移到 user2 了哦
///         email: String::from("another@example.com"),
///         ..user1
///     };
/// 
///  println!("user: {#?}", user1); // 报错： user1 的所有权已经转移到 user2 了
/// }
/// 
/// ----------------------------------------------------
/// fn main() {
///     // --snip--
/// 
///     let user2 = User {   //  user1 还是可以用哦
///         email: String::from("another@example.com"),
///          username: String::from("user2"),
///         ..user1
///     };
/// 
///  println!("user: {#?}", user1); // 可以用 user1， 因为 复制给 user2 的只有 active [bool] 和 sign_in_count [u32] ，因为基础类型实现了 Copy  trait，产生 移动所有权
///  
/// }
/// 
/// 
/// 
/// 
/// 
/// ######################################################################################################################################################
///  元组结构体   (像使用 元组一样使用)
/// ######################################################################################################################################################
/// 
/// 没有具体的字段名，只有字段的类型。
/// 
/// 【用途】：当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的
/// 
/// 
/// struct Color(i32, i32, i32);
/// struct Point(i32, i32, i32);
/// 
/// fn main() {
///     let black = Color(0, 0, 0);
///     let origin = Point(0, 0, 0);
/// }
/// 
/// 
/// ######################################################################################################################################################
///  类单元结构体
/// ###################################################################################################################################################### 
/// 
/// 它类似于 ()，即 uint 元组
/// 
/// 
/// 【用途】： 常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用
///
/// 
/// struct AlwaysEqual;
/// 
/// fn main() {
///     let subject = AlwaysEqual;
/// }
/// 
/// 
/// ######################################################################################################################################################
/// 
///  字段引用其他 类型的 struct  
/// 
/// (即 struct 的某些字段引用了其他 外部类型数据) 
/// 
/// [需要加上 生命周期, 否则报错]: 因为引用了 外部数据，而人家可能会被回收掉 从而造成 垂悬引用
/// 
/// 加上 生命周期 就可以规避这个问题
/// 
/// 
/// ###################################################################################################################################################### 
/// 
/// ------------------------------------
/// 错误示例
/// ------------------------------------
/// struct User {
///     active: bool,
///     username: &str,   --------------- missing lifetime specifier
///     email: &str,      --------------- missing lifetime specifier
///     sign_in_count: u64,  
/// }
/// 
/// fn main() {
///     let user1 = User {
///         active: true,
///         username: "someusername123",
///         email: "someone@example.com",
///         sign_in_count: 1,
///     };
/// }
///
/// 
/// ######################################################################################################################################################
///  泛型 的定义和使用  
/// ###################################################################################################################################################### 
/// 
/// 
/// // T 类型字段的 Point
/// struct Point<T> {
///     x: T,
///     y: T,
/// }
/// 
/// // 实现针对 T 类型的的 Point 的方法      （【注意：】我们可以为泛型参数选择一个与结构体定义中声明的泛型参数所不同的名称，不过依照惯例使用了相同的名称）
/// impl<T> Point<T> {
///     fn x(&self) -> &T {
///         &self.x
///     }
/// }
/// 
/// fn main() {
///     let p = Point { x: 5, y: 10 };
/// 
///     println!("p.x = {}", p.x());
/// }
/// 
/// 
/// 
/// ######################################################################################################################################################
///  结构体定义中的 泛型类型参数 并不总是 与 结构体方法签名 中使用的泛型是 同一类型 
/// ###################################################################################################################################################### 
/// 
/// 
/// 
/// 
/// 
/// struct Point<X1, Y1> {
///     x: X1,
///     y: Y1,
/// }
/// 
/// // 这个方法用 self 的 Point 类型的 x 值（类型 X1）和参数的 Point 类型的 y 值（类型 Y2）来创建一个新 Point 类型的实例.
/// 
/// // 这个例子的目的是展示一些泛型通过 impl 声明而另一些通过方法定义声明的情况。
/// // 这里泛型参数 X1 和 Y1 声明于 impl 之后，因为他们与结构体定义相对应。而泛型参数 X2 和 Y2 声明于 fn mixup 之后，因为他们只是相对于方法本身的
/// //
/// impl<X1, Y1> Point<X1, Y1> {
///     fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
///         Point {
///             x: self.x,
///             y: other.y,
///         }
///     }
/// }
/// 
/// fn main() {
///     let p1 = Point { x: 5, y: 10.4 };
///     let p2 = Point { x: "Hello", y: 'c' };
/// 
///     let p3 = p1.mixup(p2);
/// 
///     println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
/// }



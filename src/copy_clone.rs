
/// 【浅拷贝】  和  【深拷贝】
/// 
/// ********************************************************
/// ********************************************************
/// Rust 永远也不会自动创建数据的 【深拷贝】。                          因此，任何自动的复制都 不是  【深拷贝】
/// ********************************************************
/// ********************************************************
/// 
/// 
/// 
/// 1. Copy     【浅拷贝】     只发生在  【栈】
/// 
///              Copy 的特征，可以用在类似整型这样在栈中存储的类型。      如果   一个类型拥有 Copy 特征，一个旧的变量  在被赋值给 其他变量 后仍然可用
///                 
///                 任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的：     整数、浮点、bool、char、 由前面四种类型组成的 tuple、  不可变引用 &T
///                 
///                 
/// 
/// 
/// 一般发生在 【基础类型】 和 【&str】 上
/// 
/// let x = 5;
/// let y = x;
/// println!("x = {}, y = {}", x, y);   -------------------- 这行编译不报错
/// 
/// 或
/// 
/// let x: &str = "hello, world";
/// let y = x;
/// println!("{},{}",x,y);   -------------------- 这行编译不报错
/// 
/// 
/// 
/// 2. Clone      【深拷贝】      只发生在  【堆】
/// 
/// 
/// let s1 = String::from("hello");
/// let s2 = s1.clone();     ------ 深拷贝
/// 
/// println!("s1 = {}, s2 = {}", s1, s2);   -------------------- 这行编译不报错
/// 
/// 
/// 
/// 但是
/// 
/// 
/// let s1 = String::from("hello");
/// let s2 = s1;    ------ 所有权转移 move， 不是  深拷贝 clone
/// 
/// println!("{}, world!", s1);   -------------------- 编译报错  (s1 无所有权)
/// 
/// 